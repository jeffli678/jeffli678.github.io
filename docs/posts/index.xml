<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Xusheng&#39;s blog</title>
        <link>/posts/</link>
        <description>Recent content in Posts on Xusheng&#39;s blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Thu, 11 Feb 2021 18:46:24 +0800</lastBuildDate>
        <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>My New Blog is Ready!</title>
            <link>/posts/my_new_blog/</link>
            <pubDate>Thu, 11 Feb 2021 18:46:24 +0800</pubDate>
            
            <guid>/posts/my_new_blog/</guid>
            <description>I spent some time with Hugo and now my blog is hosted on GitHub. Feel free to visit it at xusheng.dev!
I will write about reversing, coding, Xiangqi, and other stuff.</description>
            <content type="html"><![CDATA[<p>I spent some time with <a href="https://gohugo.io/">Hugo</a> and now my blog is hosted on GitHub. Feel free to visit it at <a href="https://xusheng.dev">xusheng.dev</a>!</p>
<p>I will write about reversing, coding, Xiangqi, and other stuff.</p>
]]></content>
        </item>
        
        <item>
            <title>How to Avoid Writing a Bad Crackme</title>
            <link>/posts/reversing/how_to_not_write_a_bad_crackme/how_to_not_write_a_bad_crackme/</link>
            <pubDate>Tue, 29 Dec 2020 00:00:00 +0000</pubDate>
            
            <guid>/posts/reversing/how_to_not_write_a_bad_crackme/how_to_not_write_a_bad_crackme/</guid>
            <description>Recently, I was promoted to a reviewer on crackmes.one (along with @zed). I am so honored with this and I appreciate the recognition and trust from @stan (creator of crackmes.one) and the entire community. The task for a reviewer is interesting, that I read submitted solutions and verify new crackmes. This allows me to grasp the latest trend on the website.
I did not tally the statistics, but there is a fairly good amount of new submissions (of both crackmes and solutions) every week.</description>
            <content type="html"><![CDATA[<p>Recently, I was promoted to a reviewer on crackmes.one (along with @zed). I am so honored with this and I appreciate the recognition and trust from @stan (creator of crackmes.one) and the entire community. The task for a reviewer is interesting, that I read submitted solutions and verify new crackmes. This allows me to grasp the latest trend on the website.</p>
<p>I did not tally the statistics, but there is a fairly good amount of new submissions (of both crackmes and solutions) every week. And most of them are nice! For me, crackmes.one is a place for reversers to exchange knowledge and joyfulness. So I am very glad that we see a steady flow of input. Now that we have three reviewers, and I hope an increase in the reviewing speed will shorten the feedback loop for contributors, which, in turn, will lead to more contributions from the community.</p>
<p>Nevertheless, some of the submissions did not meet our standards and got rejected. The reasons vary, but many of them are using existing obfuscator/protector. Among them, many have a dull verification algorithm and the sole challenge is to get past the obfuscator. We welcome the use of protectors/obfuscators, but we do not like the use of existing ones, especially commercial ones, e.g., VMP, WinLicense. These protectors are definitely breakable (trust me), but it is too hard for a crackme and it will take very long to solve. For folks who can do it, they would probably invest the time in some more important/interesting things, rather than spending a long time on it to break the protector, and only to find the actual algorithm is just on XOR.</p>
<p>Meanwhile, using existing tools deviates from the spirit of crackmes.one. As I wrote above, I believe this is a place for us reversers to <code>&quot;exchange knowledge and joyfulness&quot;</code>. We not only practice and improve our reversing skills but also share and obtain knowledge. However, using an existing tool does not help the author learn anything, beyond how to execute the tool, which is relatively simple. Conversely, if the author digs deep into an existing (open-source) tool, understands how it works, makes certain changes to defeat existing tools, s/he would learn more.</p>
<p>Below, I will list some of the things that we should better avoid when writing a crackme. Note, these rules are not absolute and I will write a longer version of explanation following it.</p>
<h2 id="donts">Don&rsquo;ts</h2>
<ol>
<li>Do not upload crackmes that are not written by you.</li>
<li>Do not upload malware or unwanted software of any kind, e.g., trojan, ransomware, adware, etc.</li>
<li>Do not use a commercial packer, protector, or obfuscator.</li>
<li>Do not upload a crackme that you cannot solve.</li>
<li>The crackme should not fail to execute. Please, no missing library dependencies or internal errors!</li>
<li>The crackme should not make network connections to any host other than localhost (127.0.0.1).</li>
<li>The crackme me should make it clear how it accepts/expects input (if any). And it should also clearly tell the player whether the input is correct.</li>
<li>The crackme must be solvable without guessing or a non-trivial amount of brute-forcing.</li>
<li>The crackme must be solvable in a reasonable time &ndash; when solved optimally.</li>
<li>The crackme should not rely on any hardware unique identifier as part of the algorithm.</li>
<li>The crackme should not stack unrelated levels of protection together.</li>
</ol>
<h2 id="justifications">Justifications</h2>
<p>A reader might notice some of the items above are too restrictive. So I will now explain the reason to set them and some of the exceptions for it. Also, if you are in doubt about a specific crackme or crackme idea, please contact one of the reviewers on Discord.</p>
<ol>
<li>The crackme should be the uploader&rsquo;s original work. Do not upload crackmes that have potential copyright issues. Do not upload crackmes you see on the Internet or in CTFs, unless you get permission to do so.</li>
<li>An exception is that one might make a pseudo-ransomware/malware that is a reverse engineering challenge. If that is the case, be sure to limit the damage to a very small and specific range (e.g., a <code>flag.txt</code> in the current dir), and state it clearly before the actual payload runs.</li>
<li>Using commercial packers, protectors, or obfuscators does not help challenge authors to learn and improve. And it could also take too long to solve. Also, avoid using any of these tools that already exist. Making your own or improving existing tools are very welcome!</li>
<li>Related to #3 and #8, do not make a crackme that even the author cannot solve.</li>
<li>This is a disappointing situation. Try to be compatible with more systems you target. Though we know that compatibility with all systems is impossible. At least test it on another computer and see if it works!</li>
<li>We discourage the use of network connections. Network traffic makes it harder to determine whether the program has any malicious behavior. If you need to have a network connection, only do that with the localhost. If you do not wish the player to temper with the &ldquo;remote&rdquo; server, still bundle the server and run it on the localhost, but tell the player not to reverse it.</li>
<li>If the crackme accepts inputs, e.g., user name and passwords, do not obscure the way it reads it. Also, be honest and tell the player if s/he solves it. Do not accept fake flags. Do not hide the flag somewhere that cannot be triggered by code execution. Note, this rule does not state that a crackme has to do password validation. We do have crackmes that ask the player to defeat the anti-debugging or decrypt a file that gets encrypted. These are good and not affected by this rule. In other words, if you have a novel challenge style, explain it to the player so they do not get lost.</li>
<li>Do not put the flag/secret in a function that is never gonna be executed. Do not make crackmes that the player has to guess something important to proceed.</li>
<li>Most crackmes can be solved instantly, or in a few seconds. I think a max 1-minute time limit is a reasonable recommended maximum.</li>
<li>Do not blindly add layers of protection, unless they form a cohesive unity. If protections are duplicated in large numbers, there should be a way to automatically tackle it.</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>Solving Two OCaml Crackmes Without Knowing Much about OCaml</title>
            <link>/posts/reversing/ocaml_crackmes/readme/</link>
            <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
            
            <guid>/posts/reversing/ocaml_crackmes/readme/</guid>
            <description>Earlier this year, my friend Towel uploaded two OCaml crackmes to crackmes.one. One of them is Baby OCaml, and the other one is called Teenager OCaml. Well, interesting names!
This is not the first time Towel came up with OCaml crackmes. Qt Scanner, rated as level 5, is a hard challenge. I attempted that, but have not succeeded yet. So, when I first saw these two new OCaml challenges, I am not very eager to try them, despite they are rated as level 1 and 3.</description>
            <content type="html"><![CDATA[<p>Earlier this year, my friend <a href="https://crackmes.one/user/Towel">Towel</a> uploaded two OCaml crackmes to crackmes.one. One of them is <a href="https://crackmes.one/crackme/5f600af333c5d4357b3b01d6"><code>Baby OCaml</code></a>, and the other one is called <a href="https://crackmes.one/crackme/5f600b9933c5d4357b3b01d7"><code>Teenager OCaml</code></a>. Well, interesting names!</p>
<p>This is not the first time Towel came up with OCaml crackmes. <a href="https://crackmes.one/crackme/5ec1b82133c5d449d91ae539"><code>Qt Scanner</code></a>, rated as level 5, is a hard challenge. I attempted that, but have not succeeded yet. So, when I first saw these two new OCaml challenges, I am not very eager to try them, despite they are rated as level 1 and 3. Nevertheless, we cannot hide from challenges forever, so I decided to try it last week. And the outcome is good, I managed to solve them without digging deep into the OCaml runtime.</p>
<h2 id="baby-ocaml">Baby OCaml</h2>
<p>OCaml is an interpretive language, but it can be compiled to native code. This is in contrast to Python/PyInstaller, where the script is just packaged into the generated binary and we can restore the original source of it. The OCaml compiler generates native code based on the source code, and the source is not present within the generated binary. Worse still, when we deal with new programming languages, e.g., OCaml, Go, Rust, we are likely to encounter some novel things we do not expect. For example, Rust has a very different way of passing parameters and return values of a function. We need to first get familiar with it, then start reversing the actual code logic.</p>
<p>The Baby binary is 2.0 MB in size, which is HUGE for a crackme. The OCaml runtime will occupy lots of space in it, so we need to find the code that we are interested in. Opening the binary in BinaryNinja reveals that it is a statically linked binary:</p>
<p><img src="../imgs/1.png" alt=""></p>
<p>OK, so even libc functions are not easy to find. But the entry point looks so familiar to me that I can still recognize the <code>call 0x470980</code> at 0x401c48 is <code>libc_start_main</code>, and <code>sub_401770</code> at 0x401c41 is the <code>main</code> function. However, the <code>main</code> function is mostly initializing the OCaml runtime, and I cannot find the actual entry point to the code.</p>
<p>Then I decided to run the binary and see if I can get any clue from it:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">$ ./baby 
-<span style="color:#f92672">=</span> Montrehack <span style="color:#f92672">=</span>-
   Baby OCaml

<span style="color:#f92672">[</span>!<span style="color:#f92672">]</span> Nope, try again.
</code></pre></div><p>Ok, it does not ask for input, so the input should probably be supplied as a command line argument. I tried to find the strings it prints but failed. Well, the strings must be encrypted or otherwise obfuscated. Now I cannot quickly find the logic that checks the input, so again this is a dead end.</p>
<p>I tried to reverse the binary for a half-day but cannot make a breakthrough. The call stack is deep and lots of function pointers are used. I was lost and put the binary aside for a while until one day Towel poked me to try his challenges. I told him that I cannot even solve the baby one, thanks to the string obfuscation. We chatted about the challenges a little bit, and I decided to give it a try again.</p>
<p>This time, I have to admit, that I am super lucky. I browsed the string list and spotted something unusual in the first few:</p>
<p><img src="../imgs/2.png" alt=""></p>
<p>Looks readable, right? I navigated to the location and the code seems to be comparing strings:</p>
<p><img src="../imgs/3.png" alt=""></p>
<p>I am pretty sure the code is checking whether the ASCII string at <code>rax</code> is <code>Getting_Warmed_Up</code>. Note, the last char, <code>'p'</code>, with an ASCII value 0x70, is checked against 0x600000000000070. Well, due to little-endian, this will be effectively checking the lowest byte in the qword, but I have no idea what the 0x60 means. So OCaml runtime does have some weird things that are quite unusual.</p>
<p>Anyways, I solved the challenge:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">$ ./baby Getting_Warmed_Up
-<span style="color:#f92672">=</span> Montrehack <span style="color:#f92672">=</span>-
   Baby OCaml

<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Success!

FLAG-c34bc2bd73fdb06799061a8e76f62664
</code></pre></div><h2 id="tennager-ocaml">Tennager OCaml</h2>
<p>Although I did not solve the last challenge decently, I cannot wait to start working on the Teenager one. This binary is 1.9 MB in size. So, yeah, the size is mostly static libraries + OCaml runtime, and the size of the actual logic is almost negligible within it.</p>
<p>This time it does not use string obfuscation so I can easily locate the place where the binary asks for input:</p>
<p><img src="../imgs/4.png" alt=""></p>
<p>The control flow seems quite obvious, in the first node it asks for input, there there are two checks, and we must get to the lower left node to pass the check. I was pretty relieved when I saw this since there aren&rsquo;t many functions in this graph. However, it turns out I am naive and too optimistic about it.</p>
<p>The first thing that I cannot understand is&hellip;. the first check.</p>
<p><img src="../imgs/5.png" alt=""></p>
<p>At 0x403168, <code>rbx</code> must be 0x2b, from which we can deduce that <code>rbx</code> must be 0x15 at 0x403163. And tracing back, it becomes weird. From debugging I noticed at 0x40314b, <code>rax</code> actually holds the ASCII string of the input. What could be located at <code>rax-0x8</code>? Well, I am not sure, but it is highly likely to be something related to the string&rsquo;s length. However, reading the code I cannot make any sense of it. I tried inputs with different lengths and the value does not change according to the input length.</p>
<p>Furthermore, at 0x40315b there is a <code>movzx rdi, byte [rax+rbx]</code>. We know <code>rax</code> is the string, if this is one of the input char, then this check is very strange. The length will be checked against one particular char, and the result must be 0x15.</p>
<p>Luckily, I debugged the code more and find after code at 0x403160, <code>rbx</code> always holds the length of the input. So this one is checking whether the string length is 0x15. The OCaml is yet unsolved, but I managed to get some information out of it.</p>
<p>Now, there are only three functions ahead, but I cannot trace the execution easily. The code uses lots of function pointers and I quickly get lost. A patient reverser would study the OCaml compiler to figure out how the code is generated, but I still have one thing to try: hardware breakpoint on the input string.</p>
<p>The plan is simple, we now know the string is held in <code>rax</code> at 0x40314b, then we can set a hardware breakpoint on it and see who accesses it. If everything goes well, we can find the code that reads the input, which is very likely to be also the checking logic code.</p>
<p>I set a breakpoint at 0x40317f, and supplied the input string &ldquo;111111111111111111111&rdquo; (which is just &lsquo;1&rsquo; * 0x15). It hits! Not bad, at least we are correct on the length check. The pwndbg shows <code>rax</code> does point to the input string:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">RAX  0x7ffff7ff9b90 ◂— <span style="color:#e6db74">&#39;111111111111111111111&#39;</span>
</code></pre></div><p>Then I set a hardware read breakpoint:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">pwndbg&gt; rwatch *0x7ffff7ff9b95
Hardware read watchpoint 3: *0x7ffff7ff9b95
</code></pre></div><p>Note, the string starts at 0x7ffff7ff9b95, but I set a breakpoint at 0x7ffff7ff9b95, which is the 6th char of the input. This is a personal habit since there could potentially be more places that access the first char than we are interested in. On the other hand, the code that reads a char in the middle is more likely to be interesting and worth checking out.</p>
<p>The hardware breakpoint is hit at 0x402c07, and the instruction above it is reading the 6th char of the input:</p>
<p><img src="../imgs/6.png" alt=""></p>
<p>This function (sub_4024f0) looks like:</p>
<p><img src="../imgs/8.png" alt=""></p>
<p>So it is very likely that the function is checking very char one by one. This function has no xref to it at all, so I probably will not be able to find it easily, if I do not use hardware breakpoint. Inspecting the stack gives me the actual caller, 0x402410, and I have to say it is not easy to find the actual callee without debugging. The good news is if I were to reverse OCaml in the future, I know where to look at and with the help of debugging, I can hopefully find the callee and sort out the execution flow.</p>
<p><img src="../imgs/9.png" alt=""></p>
<p>I notice if the check passes, the return value is set to 0xa7. Remember the check at 0x4031e6? 0xd9f is quite a strange value, but it could be related to the 0xa7 here.</p>
<p><img src="../imgs/7.png" alt=""></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#f92672">&gt;&gt;&gt;</span> hex(<span style="color:#ae81ff">0xd9f</span><span style="color:#f92672">/</span><span style="color:#ae81ff">0x15</span>)
<span style="color:#e6db74">&#39;0xa6&#39;</span>
</code></pre></div><p>So, there is some code, which I have not discovered, that minus 1 from the return value and then sum everything up. Now we know the check for each char, and it should not be hard to dump the constraints and solve it with z3.</p>
<p>I am lazy and do not wish to manually transcript the constraints and z3 syntax. However, angr does not easily work with it, thanks to the OCaml runtime, which angr does not understand. So I need to combine the power of BinaryNinja API to simplify the binary and enable angr to work with it.</p>
<h2 id="solving-with-binaryninja-and-angr">Solving with BinaryNinja and Angr</h2>
<p><img src="../imgs/10.png" alt=""></p>
<p>If we look at the basic block at 0x402d4c, there are two inputs to it: 1) the ASCII string in <code>rax</code>, 2) the value of <code>rbx</code> set at 0x402d24. We also need to extract the char index from the instruction at 0x402d4c (0x3 for in this screenshot). To get the initial value of <code>rbx</code>, we do not need to search for the instruction at 0x402d24. Instead, we can use the possible value set of <code>rbx</code> to get it. To enable angr, we also need to get the target address of the true/false branch of the conditional at 0x402d64.</p>
<h3 id="getting-truefalse-branch-address">Getting True/False Branch Address</h3>
<p>To get the good/bad branch, we first get the <code>outgoing_edges</code> of a basic block and check the <code>edge.type</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python">bbl <span style="color:#f92672">=</span> bv<span style="color:#f92672">.</span>get_basic_blocks_at(addr)[<span style="color:#ae81ff">0</span>]
edges <span style="color:#f92672">=</span> bbl<span style="color:#f92672">.</span>outgoing_edges
<span style="color:#66d9ef">for</span> edge <span style="color:#f92672">in</span> edges:
    <span style="color:#66d9ef">if</span> edge<span style="color:#f92672">.</span>type <span style="color:#f92672">==</span> BranchType<span style="color:#f92672">.</span>TrueBranch:
        good_addr <span style="color:#f92672">=</span> edge<span style="color:#f92672">.</span>target<span style="color:#f92672">.</span>start
    <span style="color:#66d9ef">elif</span> edge<span style="color:#f92672">.</span>type <span style="color:#f92672">==</span> BranchType<span style="color:#f92672">.</span>FalseBranch:
        bad_addr <span style="color:#f92672">=</span> edge<span style="color:#f92672">.</span>target<span style="color:#f92672">.</span>start
</code></pre></div><h3 id="parsing-llil-and-getting-char-index">Parsing LLIL and Getting Char Index</h3>
<p>For each constraint, we need to know the index of the char being checked. For example, for instruction <code>movzx rax, byte [rax+0x3]</code>, we need to get 0x3 from it. This requires us to walk the LLIL instruction and find its value.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">find_llil_basic_block</span>(llil_basic_blocks, addr):
    <span style="color:#66d9ef">for</span> llil_bbl <span style="color:#f92672">in</span> llil_basic_blocks:
        <span style="color:#66d9ef">if</span> llil_bbl[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>address <span style="color:#f92672">==</span> addr:
            <span style="color:#66d9ef">return</span> llil_bbl

func <span style="color:#f92672">=</span> bv<span style="color:#f92672">.</span>get_functions_containing(addr)[<span style="color:#ae81ff">0</span>]
llil_basic_blocks <span style="color:#f92672">=</span> list(func<span style="color:#f92672">.</span>llil_basic_blocks)
llil_bbl <span style="color:#f92672">=</span> find_llil_basic_block(llil_basic_blocks, addr)
src <span style="color:#f92672">=</span> llil_bbl[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>operands[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>operands[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>operands[<span style="color:#ae81ff">0</span>]

char_idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
<span style="color:#66d9ef">if</span> src<span style="color:#f92672">.</span>operation <span style="color:#f92672">==</span> LowLevelILOperation<span style="color:#f92672">.</span>LLIL_ADD:
    char_idx <span style="color:#f92672">=</span> src<span style="color:#f92672">.</span>operands[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>value<span style="color:#f92672">.</span>value
</code></pre></div><p>Note, the above code might not be very reader-friendly, e.g., <code>src = llil_bbl[0].operands[1].operands[0].operands[0]</code>. This is because LLIL is essentially a tree, and we are travelling down it.</p>
<h3 id="getting-the-possible-value-of-rbx">Getting the Possible Value of rbx</h3>
<p>To get the possible value of rbx when the execution enters the basic block, we need to use the <code>get_possible_reg_values</code> API.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python">rbx_value <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
value_set <span style="color:#f92672">=</span> llil_bbl[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>get_possible_reg_values(<span style="color:#e6db74">&#39;rbx&#39;</span>)
<span style="color:#66d9ef">if</span> value_set<span style="color:#f92672">.</span>type <span style="color:#f92672">==</span> RegisterValueType<span style="color:#f92672">.</span>ConstantValue:
    rbx_value <span style="color:#f92672">=</span> value_set<span style="color:#f92672">.</span>value
    rbx_value <span style="color:#f92672">&amp;=</span> <span style="color:#ae81ff">0xffffffffffffffff</span>
</code></pre></div><p>Note, not all of the check uses rbx. For them, the <code>value_set.type</code> will be <code>UnderterminedValue</code>, and rbx_value will remain 0x0. This has no side effect on solving.</p>
<h3 id="angr-time">Angr Time</h3>
<p>The last step is to solve it with angr:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">angr_solve</span>(addr, good_addr, bad_addr, char_idx, rbx_value):
    proj <span style="color:#f92672">=</span> angr<span style="color:#f92672">.</span>Project(<span style="color:#e6db74">&#39;./teenager&#39;</span>)
    state <span style="color:#f92672">=</span> proj<span style="color:#f92672">.</span>factory<span style="color:#f92672">.</span>entry_state(addr <span style="color:#f92672">=</span> addr)
    <span style="color:#75715e"># suppose the input string (ASCII) is stored at 0xaa000000</span>
    input_addr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xaa000000</span>
    state<span style="color:#f92672">.</span>regs<span style="color:#f92672">.</span>rax <span style="color:#f92672">=</span> input_addr
    state<span style="color:#f92672">.</span>regs<span style="color:#f92672">.</span>rbx <span style="color:#f92672">=</span> rbx_value
    flag <span style="color:#f92672">=</span> state<span style="color:#f92672">.</span>solver<span style="color:#f92672">.</span>BVS(<span style="color:#e6db74">&#39;flag&#39;</span>, <span style="color:#ae81ff">8</span>)
    state<span style="color:#f92672">.</span>memory<span style="color:#f92672">.</span>store(input_addr <span style="color:#f92672">+</span> char_idx, flag)
    simgr <span style="color:#f92672">=</span> proj<span style="color:#f92672">.</span>factory<span style="color:#f92672">.</span>simgr(state)
    simgr<span style="color:#f92672">.</span>explore(find <span style="color:#f92672">=</span> good_addr, avoid <span style="color:#f92672">=</span> [bad_addr])
    <span style="color:#66d9ef">if</span> simgr<span style="color:#f92672">.</span>found:
        solution_state <span style="color:#f92672">=</span> simgr<span style="color:#f92672">.</span>found[<span style="color:#ae81ff">0</span>]
        char_solution <span style="color:#f92672">=</span> solution_state<span style="color:#f92672">.</span>solver<span style="color:#f92672">.</span>eval(flag, cast_to <span style="color:#f92672">=</span> bytes)
        <span style="color:#66d9ef">return</span> True, char_solution
    <span style="color:#66d9ef">else</span>:
        False, None
</code></pre></div><p>Note, the above script is not super robust, since we really expect the solving to succeed.</p>
<p>We still need to manually collect the 0x15 address of the basic blocks. Although it is possible to automatically collect them, I feel the time to make it work will be longer than just select and copy 0x15 addresses.</p>
<p>The script returns <code>0CamL_Ints_Ar3_W4rped</code>, and feeding it to the challenge gives me:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">$ ./teenager 
-<span style="color:#f92672">=</span> Montrehack <span style="color:#f92672">=</span>-
   Teenager

Enter Password: 0CamL_Ints_Ar3_W4rped

<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Success!
FLAG-221fddd2bbf810be10d156b060b0eda5
</code></pre></div><p>This reminds me of the description of the challenge:</p>
<pre><code>A slightly harder OCaml challenge to get practice with OCaml integer representations.
</code></pre><p>So, it seems that I solved without knowing anything about OCaml integer representation.</p>
]]></content>
        </item>
        
        <item>
            <title>Deciphering a Windows Anti-debugging Challenge</title>
            <link>/posts/reversing/reverseme3/readme/</link>
            <pubDate>Sun, 29 Nov 2020 00:00:00 +0000</pubDate>
            
            <guid>/posts/reversing/reverseme3/readme/</guid>
            <description>It has been a long while since I last wrote about anything. We try to post something every week, but it has been, at least for me, super busy recently. So sorry for the gap. The good news is I am going to post several writeups recently.
This time I am writing about the challenge ReverseMe3 from jochen_. The challenge can be found on crackmes.one. The password to unzip is &amp;ldquo;crackmes.</description>
            <content type="html"><![CDATA[<p>It has been a long while since I last wrote about anything. We try to post something every week, but it has been, at least for me, super busy recently. So sorry for the gap. The good news is I am going to post several writeups recently.</p>
<p>This time I am writing about the challenge <code>ReverseMe3</code> from <code>jochen_</code>. The challenge can be found on <a href="https://crackmes.one/crackme/5fb1642933c5d424269a1850">crackmes.one</a>. The password to unzip is &ldquo;crackmes.one&rdquo;.</p>
<p>The description given on the challenge page says the program will show a message box when it not running under a debugger. And the goal is to make it also show the message box when it is running under a debugger. Basically, to circumvent the anti-debugging techniques.</p>
<p>Interestingly, the author mentions the program only runs properly on <code>3 latest builds of Windows 10. 1909 2004 and 20H2</code>. And if we were to conquer it inside a VM, we have to bypass one more check. So maybe the program uses some new feature that is introduced in the latest versions? Or it might be relying on low-level/un-documented features that only work on these versions. I do not have a VM that has the proper Windows build version, so I decide to solve it statically.</p>
<p>As always, I will not only explain how to solve it correctly &ndash; I will try to mention many of my thought processes as well as some detours that I have took. I believe this is more interesting to read than a flawless straight-sail.</p>
<h2 id="first-impression">First Impression</h2>
<p>The challenge binary <code>ReverseMe3.EXE</code> is only 2.6 KB, relatively small. Loading it into BinaryNinja quickly reveals something unusual:</p>
<p><img src="../imgs/1.png" alt=""></p>
<p>It first sets <code>eax</code> to 0x40, <code>bswap</code> it, and then calls <code>cpuid</code>. the <code>bswap</code> will make eax <code>0x40000000</code>, and according to my memory that does not return anything useful for <code>cpuid</code>. However, at <code>0x40101d</code>, the return value in <code>ecx</code> is moved into <code>eax</code>, which is then used to decrypt the code starting from <code>0x401030</code>. The code to be decrypted is 0x258 bytes long. Code at <code>00401030</code> immediately follows the decryption loop, and of course, it cannot be properly disassembled since it is still encrypted.</p>
<p>From what I see now the challenge is probably hand-written. I like hand-written challenges since it can be denser in terms of tricks and traps, which is the fun of reverse engineering.</p>
<p>Note the decryption only uses one byte from the return value of <code>cpuid</code>, so it is possible to try all 256 possibilities, disassemble the decrypted code and see which one can be disassembled properly. The same technique is used in one of the crackmes in the book &ldquo;Reversing: Secrets of Reverse Engineering&rdquo;.</p>
<h2 id="cpuid">CPUID</h2>
<p>But we do not have to do the hard work, at least for now. We can see what <code>cpuid</code> is returning and decrypt the code with the correct return value. However, as stated in the challenge description, this challenge does not run properly in a VM. And we know that <code>cpuid</code> sometimes returns different values inside/outside the VM. So if we actually run the program, we probably get a wrong return value.</p>
<p>Anyways, let us have a look at of the documentation about <code>cpuid</code>. In fact, <code>eax</code> register determines the type of information that will be returned by the <code>cpuid</code>. For example, if <code>eax</code> is zero upon the execution, <code>cpuid</code> will return the maximum valid input value for basic CPUID information. Besides, a value that is larger than 0x80000000 will request extended CPUID information. However, these do not help us since the input is 0x40000000.</p>
<p>In the doc, anything between 0x40000000 - 0x4FFFFFFF is descibed as:</p>
<pre><code>Invalid. No existing or future CPU will return processor identification or feature information if the initial EAX value is in the range 40000000H to 4FFFFFFFH.
</code></pre><p>I was tempted to think the return value will be undefined, or even a certain kind of fault will be triggered. However, we see clearly from the code that not only the <code>cpuid</code> should execute properly, its return value should be stable.</p>
<p>Upon closer inspection of the documentation, I find that:</p>
<pre><code>If a value is entered for CPUID.EAX is higher than the maximum input value for basic or extended function for that processor then the data for the highest basic information leaf is returned.
</code></pre><p>I am not sure 0x40000000 is greater than 0x80000000 &ndash; maybe they do a signed comparison. Anyways, we know what is going to happen: <code>the data for the highest basic information leaf is returned.</code></p>
<p>Now that we still need to find the concrete return value. I do have a Windows VM, but that gives me 0x56 in <code>cl</code>, which after the decryption, gives me garbage rather than valid code. I am not planning to install an actual Windows machine to solve this challenge, so what should I do now?</p>
<p>I soon realize, for things like <code>cpuid</code>, it does not matter what OS I run. I am currently on Linux, but the value returned should be the same. I launched <a href="https://github.com/yrp604/rappel"><code>rappel</code></a>, an assembly REPL tool.</p>
<pre><code>&gt; mov eax, 0x40000000
&gt; cpuid
rax=00000000000008fc rbx=00000000000012c0 rcx=0000000000000064
rdx=0000000000000000 rsi=0000000000000000 rdi=0000000000000000
rip=0000000000400003 rsp=0000000000000033 rbp=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000
r11=0000000000000000 r12=0000000000000000 r13=0000000000000000
r14=0000000000000000 r15=0000000000000000
[cf=0, zf=0, of=0, sf=0, pf=0, af=0, df=0]
cs=002b  ss=0000  ds=0000  es=0000  fs=0000  gs=0000            efl=00000202
</code></pre><p>The return value of <code>ecx</code> is 0x64. Is this reliable? Will it always return the same value on different machines? I tried to find the maximum index of the basic information by calling <code>cpuid</code> when eax is set to 0:</p>
<pre><code>&gt; mov eax, 0
&gt; cpuid
rax=0000000000000016 rbx=00000000756e6547 rcx=000000006c65746e
rdx=0000000049656e69 rsi=0000000000000000 rdi=0000000000000000
rip=0000000000400003 rsp=0000000000000033 rbp=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000
r11=0000000000000000 r12=0000000000000000 r13=0000000000000000
r14=0000000000000000 r15=0000000000000000
[cf=0, zf=0, of=0, sf=0, pf=0, af=0, df=0]
cs=002b  ss=0000  ds=0000  es=0000  fs=0000  gs=0000            efl=00000202
</code></pre><p>We can see the return value of eax 9s 0x16, which means the maximum basic information is 0x16. Then I set <code>eax</code> to 0x16 and call <code>cpuid</code> again:</p>
<pre><code>&gt; mov eax, 0x16
&gt; cpuid
rax=00000000000008fc rbx=00000000000012c0 rcx=0000000000000064
rdx=0000000000000000 rsi=0000000000000000 rdi=0000000000000000
rip=0000000000400003 rsp=0000000000000033 rbp=0000000000000000
 r8=0000000000000000  r9=0000000000000000 r10=0000000000000000
r11=0000000000000000 r12=0000000000000000 r13=0000000000000000
r14=0000000000000000 r15=0000000000000000
[cf=0, zf=0, of=0, sf=0, pf=0, af=0, df=0]
cs=002b  ss=0000  ds=0000  es=0000  fs=0000  gs=0000            efl=00000202
</code></pre><p>Not bad, the same output is returned. So I am pretty confident calling <code>cpuid</code> with eax set to 0x40000000 has the same effect as calling it with 0x16. Looking for the value 0x16 in the table in Intel docs tells me that it returns <code>Processor Frequency Information Leaf</code>. For register <code>ecx</code>, it says &ldquo;Bits 15 - 00: Bus (Reference) Frequency (in MHz).&rdquo;</p>
<p>I am not sure whether this information is all the same on different machines since such bus frequency could vary in different cases. Please feel free to get in touch with me if you have any ideas about this! Anyways, if I do install a Windows machine and execute the program, I should get the same output. I proceeded with the value and used it to decrypt the 0x258 bytes of encrypted code, starting at 0x401030. BinaryNinja makes it super easy to transform the code, and the output looks valid:</p>
<p><img src="../imgs/2.png" alt=""></p>
<p>Before we proceed to analyze the decrypted code, I would like to see what is returned on a VM. I used a similar assembly REPL tool, <a href="https://github.com/zerosum0x0/WinREPL">WinREPL</a>, to checkout the result on Windows:</p>
<pre><code>&gt;&gt;&gt; mov eax, 0x40000000
&gt;&gt;&gt; cpuid
assembled (2 bytes): 0f a2
rax: 0000000040000006 rbx: 00000000786f4256 rcx: 00000000786f4256 rdx: 00000000786f4256
r8 : 0000000000000000 r9 : 0000000000000000 r10: 0000000000000000 r11: 0000000000000000
r12: 0000000000000000 r13: 0000000000000000 r14: 0000000000000000 r15: 0000000000000000
rsi: 0000000000000000 rdi: 0000000000000000
rip: 0000023ca56f000e rsp: 000000478b2fef00 rbp: 0000000000000000
flags: 00000200  CF: 0  PF: 0  AF: 0  ZF: 0  SF: 0  DF: 0  OF: 0
</code></pre><p>When we run <code>cpuid</code> with <code>eax</code> set to 0x40000000, the return value in ecx is actually the string &ldquo;VBox&rdquo;. I am not entirely sure which basic information it is trying to return, so I set <code>eax</code> to 0 to find out:</p>
<pre><code>&gt;&gt;&gt; mov eax, 0
&gt;&gt;&gt; cpuid
assembled (2 bytes): 0f a2
rax: 0000000000000016 rbx: 00000000756e6547 rcx: 000000006c65746e rdx: 0000000049656e69
r8 : 0000000000000000 r9 : 0000000000000000 r10: 0000000000000000 r11: 0000000000000000
r12: 0000000000000000 r13: 0000000000000000 r14: 0000000000000000 r15: 0000000000000000
rsi: 0000000000000000 rdi: 0000000000000000
rip: 0000023ca56f0007 rsp: 000000478b2fef00 rbp: 0000000000000000
flags: 00000200  CF: 0  PF: 0  AF: 0  ZF: 0  SF: 0  DF: 0  OF: 0
</code></pre><p>Not bad, it returns the same value when running on a real machine, 0x16. However, when I run <code>cpuid</code> with <code>eax</code> set to 0x16, I get the surprising output:</p>
<pre><code>&gt;&gt;&gt; mov eax, 0x16
&gt;&gt;&gt; cpuid
assembled (2 bytes): 0f a2
rax: 0000000000000000 rbx: 0000000000000000 rcx: 0000000000000000 rdx: 0000000000000000
r8 : 0000000000000000 r9 : 0000000000000000 r10: 0000000000000000 r11: 0000000000000000
r12: 0000000000000000 r13: 0000000000000000 r14: 0000000000000000 r15: 0000000000000000
rsi: 0000000000000000 rdi: 0000000000000000
rip: 0000023ca56f0015 rsp: 000000478b2fef00 rbp: 0000000000000000
flags: 00000200  CF: 0  PF: 0  AF: 0  ZF: 0  SF: 0  DF: 0  OF: 0
</code></pre><p>Then return values are all zero, and they are different from those returned when we set <code>eax</code> to 0x40000000. To sum up, the output is wrong in two senses: 1). when we set <code>eax</code> to 0x16, it does not return a valid CPUID information; 2). when we set <code>eax</code> to 0x40000000, it does not give the same output as if we were running <code>cpuid</code> with <code>eax</code> set to the maximum index of basic information, in this case, 0x16. So these two are subtle differences between a real machine and a VM, which can be used as VM detection as well.</p>
<h2 id="native-syscall-on-windows">Native Syscall on Windows</h2>
<p>Now it is time to analyze the decrypted code. Looking at the image above, we notice it first calls <code>NTCreateThread</code> to create a thread, whose entry is at 0x4010ce. And it then makes two system calls using the <code>syscall</code> instruction. Note the thread entry 0x4010ce is right below the code that makes syscalls, and the two syscalls do not seem to transfer the control to any other places, so it is very likely they are not doing something special.</p>
<p>But we still need to figure out what the two syscalls are doing. I did not see any challenges using <code>syscall</code> on Windows, mostly because the system call index is opaque on Windows, and they can be different across different system versions. Oh, this could be the reason why the author says it only works on specific versions of Windows &ndash; it relies on the specific index of certain system calls.</p>
<p>There are many ways to dump the system call on a Windows system. However, since my Windows VM is having a wrong build version, the system call index I can get is also probably NOT the same as the author expects. So I searched online for a bit and found something already organized the information into a nice searchable table at <a href="https://j00ru.vexillium.org/syscalls/nt/64/">https://j00ru.vexillium.org/syscalls/nt/64/</a>.</p>
<p><img src="../imgs/3.png" alt=""></p>
<p>So the first syscall is made with eax = 4, and I found it is <code>NtWaitForSingleObject</code>. And the object it waits for happens to be the newly created thread. The next system call is 0x2c, which is <code>NtTerminateProcess</code>. So the remaining code just waits for the thread to finish, and terminate the process.</p>
<p>We also see that the index for these two system calls is different on different major Windows versions, e.g., Win7 v.s. Win10, but they remain the same within different Win10 versions. So they do not account for the special requirement for the three Win10 builds.</p>
<p>So now we shift the focus of the analysis to the thread routine, as shown below:</p>
<p><img src="../imgs/4.png" alt=""></p>
<p>It starts by making a syscall 0xd, which translates to <code>NtSetInformationThread</code>, with <code>r9</code> set to 0x11, which means <code>ThreadHideFromDebugger</code>. This is a common anti-debug technique that tried to hide the thread from the debugger. The thread will continue to execute, but the debugger will no longer be notified by any debug events related to the thread.</p>
<p><img src="../imgs/5.png" alt=""></p>
<p>Next, it retrieves <code>PEB</code> at <code>gs:0x60</code>, at checks whether the field at 0x118 is equal to 0xa. Inspecting the structure with windbg shows (some output omitted):</p>
<pre><code>lkd&gt; dt _PEB
nt!_PEB
...
   +0x118 OSMajorVersion   : Uint4B
   +0x11c OSMinorVersion   : Uint4B
   +0x120 OSBuildNumber    : Uint2B
...
</code></pre><p>So it is checking whether the OSMajorVersion is 10. Yeah, so it is checking whether this is a Win10.</p>
<p><img src="../imgs/6.png" alt=""></p>
<p>Moving downward, we see that it is checking OSBuildNumber for a specific value, 0x47bb. I have no idea what it is when I first see it (though there are ways to figure it out). If the version matches, we see it is setting the dword at 0x401149 to be 0xa1. At first, I do not understand it, so I skipped it and moved to analyze the code at 0x401125.</p>
<p>The next system call it makes is 0xa5. Searching it on the previous webpage gives me an interesting result (the image is cropped to show only the important part):</p>
<p><img src="../imgs/7.png" alt=""></p>
<p>We can see on the latest two versions of Win10, i.e., version 2004 and 20H2, system call 0xa5 means <code>NtCreateDebugObject</code>. However, on version 1909, 0xa5 means a different system call and <code>NtCreateDebugObject</code> is 0xa1. Hmmm, 0xa1, does it look familiar? We have just seen it at address 0x40111e, right? And it is writing to <code>data_401149</code>, in the middle of an instruction. I suddenly understand what it is doing: it is patching the instruction at 0x401148 to <code>&quot;mov eax, 0xa1&quot;</code>, when the current system has OSBuildNumber 0x47bb.</p>
<p>Now I am pretty sure 0x47bb means Win10 version 1909. And the code uses a small patching trick to make sure that always calls <code>NtCreateDebugObject</code>, even if the system call number varies. Besides, this also explains why the program only works on a very limited number of Win10 builds: the system call number of other Win10 builds are different as well, and there is no code to take care of that.</p>
<p>A careful reader should have noticed that the code should also work on Win10 version 1903, which happens to have the system call number 0xa1 for <code>NtCreateDebugObject</code>. The only change needed is to also change the instruction to <code>&quot;mov eax, 0xa1&quot;</code> when a Win10 1903 is encountered.</p>
<p>Now, let us get back to the code itself. It is calling <code>NtCreateDebugObject</code>, which is likely to be a common anti-debugging technique. Although I know this technique, I cannot remember the details of it. So let me research the code as if it is something new to me.</p>
<p>The first thing to find out is the definition of the system call, which helps us understand the meaning of its parameters. MS does not document it, but we can still find some clue by searching withing the ReactOS source code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">NTSTATUS
<span style="color:#a6e22e">NtCreateDebugObject</span>(
    _Out_ PHANDLE DebugHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Flags
);
</code></pre></div><p>Alternatively, we can always search it with Duckduckgo and this time we will be lucky since <code>Process Hacker</code> also uses it: <a href="https://processhacker.sourceforge.io/doc/ntdbg_8h.html#aaf201d37b7597c3997ba3380de6253dd">https://processhacker.sourceforge.io/doc/ntdbg_8h.html#aaf201d37b7597c3997ba3380de6253dd</a>.</p>
<p>Among the four parameters, the interesting one is the first one, <code>DebugHandle</code>. Note the Windows x64 calling convention passes the first four parameters in the order of <code>rcx, rdx, r8, r9</code>. So we know <code>data_4015ac</code> is the returned <code>DebugHandle</code>. Then the code checks the return value and the system call <code>NtCreateDebugObject</code> must have succeeded.</p>
<p><img src="../imgs/8.png" alt=""></p>
<h2 id="anti-debugging-techniques">Anti-debugging Techniques</h2>
<p>The next basic block is longer, which starts with two system calls and also includes a function call. Note the last two instructions, i.e.,</p>
<pre><code>push 0x401288
ret
</code></pre><p>will transfer the control flow to 0x401288. The bytes at 0x401288 do not look like valid code yet, so there might be a second round of decryption. Scanning upwards I see at address 0x4011dc, 0x401288 is moved into <code>rcx</code>, along with a strange string <code>&quot;1c4TLKe6Px8M2fN7iAlC&quot;</code>. sub_401226 is very likely a decryption function! Let us have a look at it first:</p>
<p><img src="../imgs/9.png" alt=""></p>
<p>It is a rather small and simple function: it uses a string as the key to xor decrypt the given data. The actual xor happens at 0x401256. Its four parameters are:</p>
<pre><code>rcx: data to decrypt
rdx: data length
r8:  xor key
r9:  key length
</code></pre><p>Comparing these with the call-site at 0x4011f8, we can know that the data (code) at 0x401288 is 0x143 bytes long, and the xor key is <code>&quot;1c4TLKe6Px8M2fN7iAlC&quot;</code>, which is 0x14 bytes long.</p>
<p>However, if we proceed to decrypt the code, we will get the wrong result. The author sets up another trap here. The xor key string is written to before the decryption. This can be seen in a more obvious way if we define it as a string:</p>
<p><img src="../imgs/10.png" alt="">
<img src="../imgs/11.png" alt=""></p>
<p><code>xor_key[4]</code> and <code>xor_key[0x13]</code> are both changed before the decryption. And the new value is derived from <code>data_4014b8</code> and <code>data_4015bc</code>, which we need to figure out now.</p>
<p><code>data_4015bc</code> is easier to figure out, since we get cross reference to it, right in the code above:</p>
<p><img src="../imgs/12.png" alt=""></p>
<p>It is calling <code>NtQueryInformationThread</code> with the second parameter being <code>ThreadHideFromDebugger</code> to query whether <code>ThreadHideFromDebugger</code> is set. Remember the code at 0x4010ef, which uses <code>NtSetInformationThread</code> to set <code>ThreadHideFromDebugger</code> to true (0x1)? Here, the code is checking its value. It is trying to verify we do not change the value. Since a common way to circumvent the <code>ThreadHideFromDebugger</code> is to skip the <code>NtQueryInformationThread</code> call, in which case the thread will not hide from the debugger, but the query result will return false (0x0). Further, the program does not check whether the return value is true or false, rather it uses it as part of the decryption key. Had the program been running outside of a debugger, <code>data_4015bc</code> should have value 0x1 at 0x4011b6. If the value is altered, the program will appear to be running fine, but the decrypted code will contain errors.</p>
<p>This is an aha moment in reversing, and it is one of the reasons I love reversing. Although I do not know the author of the challenge when I reached this point, I enjoy the obstacle he set up here. It even feels that we had a short but pleasant virtual conversation about this challenge.</p>
<p>Also, this reminds me of checking out the implementation of <a href="https://github.com/x64dbg/ScyllaHide">ScyllaHide</a>, the popular anti-anti-debug plugin for x64db, to see if it handles this correctly. Which I will cover at the end of the write-up.</p>
<p>What about <code>data_4014b8</code>? There is no xref to it. But it is pretty close to another data variable <code>data_4014a8</code>,</p>
<p><img src="../imgs/13.png" alt=""></p>
<p><code>data_4014a8</code> is referenced in the remaining system all that we have not analyzed yet:</p>
<p><img src="../imgs/14.png" alt=""></p>
<p>If <code>data_4014a8</code> is a non-trivial structure, then <code>data_4014b8</code> is very likely a field inside of it. And its value will be determined by the <code>NtQueryObject</code> call.</p>
<p><code>NtQueryObject</code> happens to be <a href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntqueryobject">documented</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">__kernel_entry NTSYSCALLAPI NTSTATUS <span style="color:#a6e22e">NtQueryObject</span>(
  HANDLE                   Handle,
  OBJECT_INFORMATION_CLASS ObjectInformationClass,
  PVOID                    ObjectInformation,
  ULONG                    ObjectInformationLength,
  PULONG                   ReturnLength
);
</code></pre></div><p><code>rdx</code> is <code>ObjectInformationClass</code> and its value is 0x2, <code>r8</code> holds <code>ata_401478</code> and it is the <code>ObjectInformation</code> that we are interested in.</p>
<p>Searching the MSVC headers or ReactOS source gives the following definition for <code>OBJECT_INFORMATION_CLASS</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">enum</span> _OBJECT_INFORMATION_CLASS {
    ObjectBasicInformation,
    ObjectNameInformation,
    ObjectTypeInformation,
    ObjectAllTypesInformation,
    ObjectHandleInformation
} OBJECT_INFO_CLASS;
</code></pre></div><p>And 0x2 for <code>ObjectInformationClass</code> means <code>ObjectTypeInformation</code>.</p>
<p>The reverse-engineered definition of <code>OBJECT_TYPE_INFORMATION</code> can be found at <a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ob/obquery/type.htm">geoffchappell&rsquo;s site</a>:</p>
<p><img src="../imgs/15.png" alt=""></p>
<p>(The screenshot is cut short to save space)</p>
<p>We can do the calculation and find <code>data_4014a8</code> is at offset 0x10 into the structure at <code>data_4014a8</code>, and the field is <code>ULONG TotalNumberOfObjects</code>. What is the <code>correct</code> value of <code>TotalNumberOfObjects</code>, if the program is not being debugged? Details can be found <a href="https://ntquery.wordpress.com/2014/03/30/anti-debug-ntqueryobject/">here</a> and it should be 0x1. Now the code looks like this:</p>
<p><img src="../imgs/16.png" alt=""></p>
<p>And we know both <code>object_type.TotalNumberOfObjects</code> and <code>thread_hide_from_debugger</code> is 0x1, so we can deduce <code>xor_key[4]</code> will be changed to 0x42 (&lsquo;B&rsquo;), and <code>xor_key[0x13]</code> will be changed to 0x51 (&lsquo;Q&rsquo;). And the <code>xor_key</code> becomes <code>&quot;1c4TBKe6Px8M2fN7iAlQ&quot;</code>. Decrypting 0x143 bytes starting from 0x401288 gives me the following code:</p>
<p><img src="../imgs/17.png" alt=""></p>
<h2 id="resolving-dll-imports-with-function-name-hash">Resolving DLL Imports with Function Name Hash</h2>
<p>The call at 0x40129c and 0x4012b7 looks way too familiar to me. It is finding the address of a particular function inside a DLL. The difference between the ordinary GetProcAddr is that it uses a hash of the function name, rather than the function name itself for the lookup. There is a <code>uint32_t hash(char* function_name)</code> that returns a dword as the hash for the function name. And the code walks the export table of the given DLL, calculate the hash of every export function, and see if there is a match. In this example, the two hashes are 0xa216a185 and 0x9a9c4525.</p>
<p>How do we know which function it tries to find? Well, for this simple example, we can guess from the code that the first one is a <code>LoadLibraryA</code>, and the second one is a <code>MessageBoxA</code> (from the challenge description). However, if we need to deobfuscate a lot of functions, guessing is not a good idea.</p>
<p>There are mostly two ways to deal with it. The first one is to run the code, ask itself to find the function, and we just write it down. This is helpful when the number of functions is small, and the code can run properly. If we are analyzing a large binary or a memory dump, then it is not feasible.</p>
<p>The second way is to reverse engineer the hash function, enumerate the export table of the DLL, and try to find a match by ourselves.</p>
<p><img src="../imgs/18.png" alt=""></p>
<p>The function needs to process the PE format so it is not trivial. But there is a shortcut to deal with it. We can see the loop at 0x401372 is operating on a string in <code>rsi</code>, and the result is put into <code>rdi</code>. At 0x401381, the calculated hash is compared with the <code>expected_hash</code>, which is an argument of the function. If they match, the code proceeds to find the address of the function; if they do not match, the code proceeds to the next loop.</p>
<p>So we only need to reverse engineer the loop at 0x401372. A Python equivalent is:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rol</span>(val, n):
    bin_str <span style="color:#f92672">=</span> bin(val)[<span style="color:#ae81ff">2</span>:]
    bin_str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;0&#39;</span> <span style="color:#f92672">*</span> (<span style="color:#ae81ff">32</span> <span style="color:#f92672">-</span> len(bin_str)) <span style="color:#f92672">+</span> bin_str
    bin_str <span style="color:#f92672">=</span> bin_str[n : ] <span style="color:#f92672">+</span> bin_str[ : n]
    <span style="color:#66d9ef">return</span> int(bin_str, <span style="color:#ae81ff">2</span>)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">calc_hash</span>(name):
    val <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> name:
        val <span style="color:#f92672">+=</span> ord(c)
        val <span style="color:#f92672">&amp;=</span> <span style="color:#ae81ff">0xffffffff</span>
        val <span style="color:#f92672">=</span> rol(val, ord(c) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">31</span>)
    <span style="color:#66d9ef">return</span> val

<span style="color:#75715e"># prints 0xa216a185</span>
<span style="color:#66d9ef">print</span>(calc_hash(<span style="color:#e6db74">&#39;LoadLibraryA&#39;</span>))
<span style="color:#75715e"># prints 0x9a9c4525</span>
<span style="color:#66d9ef">print</span>(calc_hash(<span style="color:#e6db74">&#39;MessageBoxA&#39;</span>))
</code></pre></div><p>There is one thing worth noting about at 0x401377, the code is <code>&quot;rol edi, cl&quot;</code> where the <code>cl</code> is the next input char. <code>cl</code> can be (and likely is) larger than 31 since it is an ASCII char. However, the <code>edi</code> is only 32 bits wide, what would happen? Well, I studied the behavior of this case earlier in another <a href="https://github.com/jeffli678/writeups/blob/master/shl_undefined_behavior/writeup.md">writeup</a>, and the conclusion is:</p>
<pre><code>The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W is used). The count range is limited to 0 to 31 (or 63 if 64-bit mode and REX.W is used).
</code></pre><p>In other words, only the lowest 5 bits of the input char will be involved in the <code>rol</code> operation. And that is also the reason that I wrote <code>val = rol(val, ord(c) &amp; 31)</code> in the Python code.</p>
<!-- raw HTML omitted -->
<p>Another interesting thing is the way the author passes the DLL handle. The second handle, i.e. the handle of <code>user32.dll</code>, is returned by <code>LoadLibraryA</code> so there is nothing special about it. But for the first handle, we can find <code>LoadLibraryA</code> from it, which indicates the module must be <code>kernel32.dll</code>. How does the author get it? We can see it is passed in by <code>r15</code> at 0x401288. Tracing back to the previous function we see <code>mov r15, qword [rel 0x4015c4]</code>, and cross-reference of <code>data_4015c4</code> brings me back to the very beginning of <code>_start</code>:</p>
<p><img src="../imgs/19.png" alt=""></p>
<p>I noticed this piece of code when I started the journey, but I do not immediately understand it then. But now it is another aha moment! Note this is a hand-written program, so its entry point is where the execution starts. This is different from a compiled program where the <code>main()</code> function is called by the C runtime.</p>
<p>Who calls the entry point? Well, it is somebody inside of the <code>kernel32.dll</code>. Then the author clears the <code>ax</code>, and subtract 0x10000 from <code>rax</code> to get the base of <code>kernel32.dll</code>. This is related to memory alignment, the behavior of ASLR, as well as the offset of the callee into the base of the DLL. I am not sure it always works, but it looks fine to me. In the end, the base of <code>kernel32.dll</code> is saved into <code>data_4015c4</code>.</p>
<p>Alright, we have deciphered all the secrets of this challenge!</p>
<p>This is a small binary so we can reverse all of the bytes in it. I notice there are some bytes under the <code>GetProcAddr</code> function, which looks like this:</p>
<p><img src="../imgs/20.png" alt=""></p>
<p>The <code>4883</code> in the beginning tells me it is probably code, and defining a function there gives me:</p>
<p><img src="../imgs/21.png" alt=""></p>
<p>Ha, another call to <code>MessageBoxA</code>. And this one is calling the one in the IAT table, whereas the real one is dynamically resolved.</p>
<h2 id="ntcreatethreadex-and-thread_create_flags_hide_from_debugger">NtCreateThreadEx and THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER</h2>
<p>The original challenge asked us to make the program run properly and also pop up a MessageBox even when it runs under a debugger. Since we have analyzed all its tricks, I think it would not be hard at all to do it. To do this, I downloaded the Win10 20H2 ISO and installed a VM.</p>
<p>The first patch needed is to hardcode the return value (0x64) of <code>cpuid</code>. I patched the following four instructions:</p>
<pre><code>mov eax, 0x40
bswap eax
cpuid
mov eax, ecx
</code></pre><p>to</p>
<pre><code>mov eax, 0x64
</code></pre><p>and copies the patched binary to VM. Now if I double-click it, it does run and the MessageBox pops up:</p>
<p><img src="../imgs/22.png" alt=""></p>
<p>Not bad, it works!</p>
<p>The next step is to remove the anti-debugging checks. The simplest way is to remove the calls to <code>NtSetInformationThread</code>, <code>NtQueryInformationThread</code>, <code>NtCreateDebugObject</code> and <code>NtQueryObject</code>. And hardcode the expected value, or directly change the <code>xor_key</code>. However, before I make those patches, I found the breakpoint at 0x4010ce is never triggered. The debuggee simple exits.</p>
<p>The first mistake I made is using software breakpoint on self-modifying code. We know that software breakpoint works by patching the byte to 0xcc. The debugger internally keeps a list of addresses of software breakpoints and the original byte value so it will still display the old byte value if we display it. However, things get tricky when the code self-modifies. The 0xcc byte will be overwritten by the new byte value, and it is no longer a breakpoint. Now if the execution reaches the address where we put a breakpoint, it will not fire since the actual byte value is NOT 0xcc. If in a good case, another breakpoint hit (or any other debug event happens) and the debugger gets a chance to inspect the list of breakpoints and see one of them is changed from 0xcc to a new different value, then it can reason:</p>
<pre><code>Ok, this byte was 0x12, and I changed it to 0xcc. Now it is 0xab.
What happened? It must be the program modifies the byte.
I simply need to restore it to 0xcc, and update the &quot;original value&quot; of this byte to 0xab.
</code></pre><p>If this is the case, the debugger can handle self-modifying code properly. Unfortunately, the case I encounter is the bad case where the modified breakpoint is the one that is expected to fire. So there is no way it works. And the only way is to use a hardware breakpoint (or trace it with single-step).</p>
<p>Nevertheless, even if I used hardware breakpoint on the thread entry it still does not hit. Later, I found the secret is with <code>NtCreateThreadEx</code>. I do not know any anti-debugging tricks with it, so I naively think I can set a breakpoint on the thread entry point and wait there. However, this <a href="https://ntquery.wordpress.com/2014/03/29/anti-debug-ntcreatethreadex/">blog post</a> explains an anti-debugging with <code>NtCreateThreadEx</code>: setting the <code>CreateFlags</code> to <code>THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER</code> (0x4) will also hide the debuggee from the debugger, which has the same effect as calling <code>NtSetInformationThread</code> with <code>ThreadHideFromDebugger</code>. So no wonder the breakpoint on the thread routine will not hit at all! The thread is hidden from the debugger.</p>
<p>This is easy to fix once I understand the trick. Since the code is decrypted before it runs, if we were to patch it we need to make sure we patch the encrypted bytes so the decrypted code is what we want. This is possible, especially when the decryption is just xor. However, I am a little bit lazy and I decide to bypass it in a debugger, i.e., change <code>rbx</code> back to 0, right after the code set it to 0x4 at 0x401034. Now the breakpoint on the thread entry point hits.</p>
<p>Then I directly set the <code>rip</code> to 0x4011b6:</p>
<p><img src="../imgs/16.png" alt=""></p>
<p>And manually set the value of <code>object_type.TotalNumberOfObjects</code> and <code>thread_hide_from_debugger</code> to 1. Then press F9 to run the program, and the MessageBox pops up:</p>
<p><img src="../imgs/23.png" alt=""></p>
<p>Nice, I have COMPLETELY analyzed the program and explained lots of details in it. I hope you like this write-up! And feel free to get in touch with me if you have any questions or suggestions.</p>
]]></content>
        </item>
        
        <item>
            <title>Dealing with Manipulated ELF Binary and Manually Resolving Import Functions</title>
            <link>/posts/reversing/elf_format/readme/</link>
            <pubDate>Sun, 30 Aug 2020 00:00:00 +0000</pubDate>
            
            <guid>/posts/reversing/elf_format/readme/</guid>
            <description>Unfortunately, this writeup is delayed for almost a week because I am super busy recently. Please take my apologies and I will try my best to keep the weekly challenge going, forever!
The challenge can be downloaded at https://crackmes.one/crackme/5e727daa33c5d4439bb2decd. It is created by user BinaryNewbie, who is NOT a newbie for binary reversing.
We will discuss an important topic in this writeup: how to mutate binary executable to obstruct reverse engineering tools.</description>
            <content type="html"><![CDATA[<p>Unfortunately, this writeup is delayed for almost a week because I am super busy recently. Please take my apologies and I will try my best to keep the weekly challenge going, forever!</p>
<p>The challenge can be downloaded at <a href="https://crackmes.one/crackme/5e727daa33c5d4439bb2decd">https://crackmes.one/crackme/5e727daa33c5d4439bb2decd</a>. It is created by user BinaryNewbie, who is NOT a newbie for binary reversing.</p>
<p>We will discuss an important topic in this writeup: how to mutate binary executable to obstruct reverse engineering tools. Specifically, these techniques aim to fool the binary parsers so that they fail to parse the binary or the parsing result is missing important information. In the worst case, the binary crashes the analysis tool. For convenience, we will call these techniques <code>Executable Format Manipulation (EFP)</code>.</p>
<p>These scenarios are especially discouraging for reversers since they cannot even get started easily. That said, these techniques are not resilient to determined reversers since they can study the file format and figure out what has caused the issue, and fix the binary to allow a better analysis, or improve the binary parser if it is open-source.</p>
<p>EFP often leverages the ambiguity in the executable format specification as well as the gap between the code that enforces the format and the specification. Executable formats are complex to implement, and for several reasons, the executable parser/loader in the operating system can differ from the docs slightly. It is also hard for an analysis tool to precisely replicate the behavior of the OS parser, so this enables the EFP to create binaries that can be executed properly but is hard to analyze properly.</p>
<h2 id="stage-one">Stage One</h2>
<p>This crackme comes with a relatively simple first stage. It is carried out inside the main() function at 0xa80. Since it is not related to what I want to discuss, I will skip the reversing part and only give the algorithm. It first retrieves the currently logged-in user name, and then calculate a key as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python">name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;jeff&#39;</span>
val <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
<span style="color:#66d9ef">for</span> i, c <span style="color:#f92672">in</span> enumerate(name):
    val <span style="color:#f92672">+=</span> ord(c)
    val <span style="color:#f92672">^=</span> i
    val <span style="color:#f92672">^=</span> <span style="color:#ae81ff">0xf</span>
</code></pre></div><p>My user name is &ldquo;jeff&rdquo; so the corresponding value is 385. Now I can get past the first stage and proceed to the real challenge.</p>
<h2 id="stage-two">Stage Two</h2>
<p>After we pass the first check, we can see that it loads another program from 0x202020. It starts with <code>&quot;\x7fELF&quot;</code>, which is the sign of another ELF. By analyzing the loader code we also know its size is 0x2008. We save this file to the disk and it can be executed properly. We will now work on this file from now. The file is included in the repo and its sha1 sum is <code>1d31fac493665f8baa23baac8e1aa5385dd1ace2</code>.</p>
<p>BinaryNinja and Ghidra fail to parse it as a valid ELF and can only load it as raw binary. Cutter can load the binary and identify some code (probably thanks to linear sweep), but it cannot find the entry point and cannot find any important functions.</p>
<p>This immediately tells me that there is something unusual with this file, we need to examine it, especially the header, closely.</p>
<p>There are two tools that I often use to inspect a file format. The first one is <a href="https://kaitai.io/">Kaitai Struct</a>, which is a <code>declarative binary format parsing language</code>. It is specifically designed to ease the development of binary parsers and it can show the parsed binary in a tree view. For many popular formats, including ELF, the community already contributed parsers. It has an <a href="https://ide.kaitai.io/">online IDE</a> so we do not have to install it. There is a <a href="https://github.com/Vector35/kaitai">BinaryNinja plugin</a> for it, as well.</p>
<p><img src="../imgs/1.png" alt=""></p>
<p>Unfortunately, this file also triggers an error in the Kaitai parser so we cannot easily view it in the tree view. This is a big drawback since we lose a strong tool. But we still have other options.</p>
<p><a href="https://www.sweetscape.com/010editor/">010Editor</a> is another option for binary format inspection. It is primarily a hex editor, but it comes with <code>template</code> that describes various file formats and can show the parse result in a table view. Templates can be downloaded from <a href="https://www.sweetscape.com/010editor/repository/templates/">here</a> or installed from within the program.</p>
<p>010Editor also fails to parse it without issue. However, it can show partial parse results so we can at least see what is normal and what could be wrong. Besides, if no tool can parse it at all, we can still manually inspect it and find and defeat any tricks in it. The 010Editor parsing result looks like this:</p>
<p><img src="../imgs/2.png" alt=""></p>
<p>The ELF magic looks fine. Immediately after that, we find something unusual, the ELF class byte (offset 0x4) is set to none, whereas it should set to 1 for 32-bit programs and 2 for 64-bit programs. Cutter already showed us some code snippets in it and it is x64 code. So we set it to 0x2. At byte 0x5, the endianness is also not set, which is probably little-endian since it runs properly on my little-endian Linux system. Next, the EI_VERSION at byte 0x6 is set to 0x1 in most ordinary binaries.</p>
<p>After we fix these three fields, BinaryNinja is now able to load it as ELF and find the entry point:</p>
<p><img src="../imgs/3.png" alt=""></p>
<p>Not bad, but we are missing symbols. I have reversed lots of binaries on Linux so <code>data_201fe0</code> is actually <code>__libc_start_main</code> and <code>data_a50</code> is the main() function. After I define the function, it looks like this:</p>
<p><img src="../imgs/4.png" alt=""></p>
<p>The complexity of the CFG is OK. But since we are missing all imported functions, we have no clue of what this program is doing. If i double click <code>sub_980</code>, it is essentially a jmp to a PLT function.</p>
<p><img src="../imgs/5.png" alt=""></p>
<p>Which means it is an imported function. Had this binary not been tampered with, we should already know what it is.</p>
<p>Since we have fixed the binary, 010Editor can parse it without any errors. We see that all of the section headers are removed, and the number of segments is also less than usual.</p>
<p><img src="../imgs/6.png" alt=""></p>
<p>The readers might have heard of that section headers are not important for ELF file executions. Linux only uses information in segments to load the binary and kick off the execution. However, since sections typically exist (generated by compilers) and contain more information than the segments, many reverse engineering tools use information from sections to parse the binary. Now that the section headers are wiped out, they cannot function properly.</p>
<p>There is a <code>e_shoff</code> field in the ELF header that points to the start of the section headers. Section headers, when they exist, are organized into an array and placed at the end of the binary. Of course, they do not have to be there &ndash; as long as the <code>e_shoff</code> actually points to the start of it. In several obfuscated ELF binaries that I reversed, the <code>e_shoff</code> is wiped out but the section headers are left intact at the end of the file. For that case, it is easy to repair since we simply need to count how many sections do we have and find out the start of the array accordingly.</p>
<p>However, for this particular binary, the <code>e_shoff</code> and the actual section headers are both wiped out. It is very hard to recover all the section headers since there are lots of information on it.</p>
<p>Note, however, I am not saying the sections are wiped out. No, impossible. Only the section headers are gone. Sections still contain data that is crucial for the execution. And it is highly likely that they are not touched. Though we do not know the boundaries of each of them, so we cannot recover them.</p>
<p>But here is a problem: if we cannot resolve the imports, how could the loader resolve them? The programs execute properly. So there must be a way!</p>
<p>We still have segments and the loader relies on segments to resolve imports. Do segments store the information at another place so it still works? Well, sections and segments overlap. We do not know where sections are since we do not have the section headers, but the segments contain offsets to useful information and can help the loader. Nevertheless, the information in segments is organized in a different format so existing tools do not parse them well. We can either reconstruct a part of the section headers so the analysis tool can parse the imports correctly, or we replace the loader by ourselves &ndash; parse the imports directly. This is especially doable for Linux since everything is open-source.</p>
<p>It is noteworthy that there is a third approach &ndash; debug the program and see where those stub function jumps into, so that we can resolve the imports semi-manually. I have used this previously for a PE challenge where the imported APIs are obfuscated. This is a small crackme and we do not have lots of them, so the workload is fine. However, when I try to run it in gdb, gdb fails to parse the binary too. It cannot find <code>__libc_start_main</code> so we cannot properly debug it. I would say gdb could do a better job but enhancing gdb right now is not an option for me.</p>
<p>So I turned to another approach &ndash; resolve the imports via a script.</p>
<h2 id="non-lazy-symbols">Non-lazy symbols</h2>
<p>We will start with non-lazy symbols first. Non-lazy symbols are resolved by the loader at loading time. The first thing we need is the DYNAMIC segment. The segments are described in an array of <code>Elf64_ProgramHeader</code> in the ELF header. For this particular binary, it is the No.4 one inside the array.</p>
<pre><code>00000120      [0x4] = 
00000120      {
00000120          enum p_type type = PT_DYNAMIC
00000124          enum p_flags flags = PF_R
00000128          uint64_t offset = 0x0
00000130          uint64_t virtual_address = 0x201d58
00000138          uint64_t physical_address = 0x0
00000140          uint64_t file_size = 0x0
00000148          uint64_t memory_size = 0x0
00000150          uint64_t align = 0x0
00000158      }
</code></pre><p>We see that the DYNAMIC segment starts at offset <code>0x201d58</code>. It contains an array of structure <code>Elf64_Dyn</code>, whose definition is:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>
{
  Elf64_Sxword  d_tag;          <span style="color:#75715e">/* Dynamic entry type */</span>
  <span style="color:#66d9ef">union</span>
    {
      Elf64_Xword d_val;        <span style="color:#75715e">/* Integer value */</span>
      Elf64_Addr d_ptr;         <span style="color:#75715e">/* Address value */</span>
    } d_un;
} Elf64_Dyn;
</code></pre></div><p>Among the two fields, <code>d_tag</code> specifies the type of it. And depending on the value of <code>d_tag</code>, <code>d_un</code> could be either an address or an integer value. Some legal values for <code>d_tag</code> are:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#75715e">/* Legal values for d_tag (dynamic entry type).  */</span>

<span style="color:#75715e">#define DT_NULL     0       </span><span style="color:#75715e">/* Marks end of dynamic section */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_NEEDED   1       </span><span style="color:#75715e">/* Name of needed library */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_PLTRELSZ 2       </span><span style="color:#75715e">/* Size in bytes of PLT relocs */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_PLTGOT   3       </span><span style="color:#75715e">/* Processor defined value */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_HASH     4       </span><span style="color:#75715e">/* Address of symbol hash table */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_STRTAB   5       </span><span style="color:#75715e">/* Address of string table */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_SYMTAB   6       </span><span style="color:#75715e">/* Address of symbol table */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_RELA     7       </span><span style="color:#75715e">/* Address of Rela relocs */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_RELASZ   8       </span><span style="color:#75715e">/* Total size of Rela relocs */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_RELAENT  9       </span><span style="color:#75715e">/* Size of one Rela reloc */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_STRSZ    10      </span><span style="color:#75715e">/* Size of string table */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_SYMENT   11      </span><span style="color:#75715e">/* Size of one symbol table entry */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_INIT     12      </span><span style="color:#75715e">/* Address of init function */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_FINI     13      </span><span style="color:#75715e">/* Address of termination function */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_SONAME   14      </span><span style="color:#75715e">/* Name of shared object */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_RPATH    15      </span><span style="color:#75715e">/* Library search path (deprecated) */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_SYMBOLIC 16      </span><span style="color:#75715e">/* Start symbol search here */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_REL      17      </span><span style="color:#75715e">/* Address of Rel relocs */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_RELSZ    18      </span><span style="color:#75715e">/* Total size of Rel relocs */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_RELENT   19      </span><span style="color:#75715e">/* Size of one Rel reloc */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_PLTREL   20      </span><span style="color:#75715e">/* Type of reloc in PLT */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_DEBUG    21      </span><span style="color:#75715e">/* For debugging; unspecified */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_TEXTREL  22      </span><span style="color:#75715e">/* Reloc might modify .text */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_JMPREL   23      </span><span style="color:#75715e">/* Address of PLT relocs */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_BIND_NOW 24      </span><span style="color:#75715e">/* Process relocations of object */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_INIT_ARRAY   25      </span><span style="color:#75715e">/* Array with addresses of init fct */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_FINI_ARRAY   26      </span><span style="color:#75715e">/* Array with addresses of fini fct */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_INIT_ARRAYSZ 27      </span><span style="color:#75715e">/* Size in bytes of DT_INIT_ARRAY */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_FINI_ARRAYSZ 28      </span><span style="color:#75715e">/* Size in bytes of DT_FINI_ARRAY */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_RUNPATH  29      </span><span style="color:#75715e">/* Library search path */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_FLAGS    30      </span><span style="color:#75715e">/* Flags for the object being loaded */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_ENCODING 32      </span><span style="color:#75715e">/* Start of encoded range */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_PREINIT_ARRAY 32     </span><span style="color:#75715e">/* Array with addresses of preinit fct*/</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_PREINIT_ARRAYSZ 33       </span><span style="color:#75715e">/* size in bytes of DT_PREINIT_ARRAY */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_SYMTAB_SHNDX 34      </span><span style="color:#75715e">/* Address of SYMTAB_SHNDX section */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_NUM      35      </span><span style="color:#75715e">/* Number used */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_LOOS     0x6000000d  </span><span style="color:#75715e">/* Start of OS-specific */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_HIOS     0x6ffff000  </span><span style="color:#75715e">/* End of OS-specific */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_LOPROC   0x70000000  </span><span style="color:#75715e">/* Start of processor-specific */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_HIPROC   0x7fffffff  </span><span style="color:#75715e">/* End of processor-specific */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_PROCNUM  DT_MIPS_NUM </span><span style="color:#75715e">/* Most used by any processor */</span><span style="color:#75715e">
</span></code></pre></div><p>There are many important information in this array. For example, there are six fields related to INIT and FINI, i.e., <code>DT_INIT</code>, <code>DT_FINI</code>, <code>DT_INIT_ARRAY</code>, <code>DT_INIT_ARRAYSZ</code>, <code>DT_FINI_ARRAY</code>, <code>DT_FINI_ARRAYSZ</code>. However, those relevant to the resolving of import functions are listed below:</p>
<pre><code>00201d58  struct Elf32_Dyn _.dynamic[26] =  
00201d58  {
00201dd8      [0x8] = 
00201dd8      {
00201dd8          enum Elf64_Sxword d_tag = DT_STRTAB
00201de0          uint64_t d_ptr = 0x4e8
00201de8      }
00201de8      [0x9] = 
00201de8      {
00201de8          enum Elf64_Sxword d_tag = DT_SYMTAB
00201df0          uint64_t d_ptr = 0x2c0
00201df8      }
00201df8      [0xa] = 
00201df8      {
00201df8          enum Elf64_Sxword d_tag = DT_STRSZ
00201e00          uint64_t d_ptr = 0x113
00201e08      }
00201e08      [0xb] = 
00201e08      {
00201e08          enum Elf64_Sxword d_tag = DT_SYMENT
00201e10          uint64_t d_ptr = 0x18
00201e18      }
00201e28      [0xd] = 
00201e28      {
00201e28          enum Elf64_Sxword d_tag = DT_PLTGOT
00201e30          uint64_t d_ptr = 0x201f48
00201e38      }
00201e38      [0xe] = 
00201e38      {
00201e38          enum Elf64_Sxword d_tag = DT_PLTRELSZ
00201e40          uint64_t d_ptr = 0x168
00201e48      }
00201e58      [0x10] = 
00201e58      {
00201e58          enum Elf64_Sxword d_tag = DT_JMPREL
00201e60          uint64_t d_ptr = 0x788
00201e68      }
00201e68      [0x11] = 
00201e68      {
00201e68          enum Elf64_Sxword d_tag = DT_RELA
00201e70          uint64_t d_ptr = 0x680
00201e78      }
00201e78      [0x12] = 
00201e78      {
00201e78          enum Elf64_Sxword d_tag = DT_RELASZ
00201e80          uint64_t d_ptr = 0x108
00201e88      }
00201ef8  }

</code></pre><p>We can see that <code>DT_STRTAB</code> has value 0x4e8, which means the string table starts at offset 0x468. Also, the <code>DT_STRSZ</code> is 0x113, so the size of the string table is 0x113. This can be verified in the following image:</p>
<p><img src="../imgs/7.png" alt=""></p>
<p>We can see many familiar names in it, e.g., <code>srand</code>, <code>time</code>, and <code>malloc</code>. These are the names of imported functions. Now what we need to figure out is how these are linked with symbols so that we can know which symbol corresponds to which name.</p>
<p>The next thing we should look at is the symbol table. <code>DT_SYMTAB</code> is 0x2c0, which means the symbol table starts at 0x2c0. <code>DT_SYMENT</code> is 0x18, which suggests there are 0x18 = 24 symbol entries. Interestingly, there are 23 entries, which I do not fully understand. If anyone has any idea on this, feel free to help me out.</p>
<p>Each symbol entry is an <code>Elf64_Sym</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>
{
  Elf64_Word    st_name;        <span style="color:#75715e">/* Symbol name (string tbl index) */</span>
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> st_info;        <span style="color:#75715e">/* Symbol type and binding */</span>
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> st_other;       <span style="color:#75715e">/* Symbol visibility */</span>
  Elf64_Section st_shndx;       <span style="color:#75715e">/* Section index */</span>
  Elf64_Addr    st_value;       <span style="color:#75715e">/* Symbol value */</span>
  Elf64_Xword   st_size;        <span style="color:#75715e">/* Symbol size */</span>
} Elf64_Sym;
</code></pre></div><p>Due to space limitation, I will only show the first three symbol entries here:</p>
<pre><code>000002c0  struct Elf64_Sym data_2c0[23] = 
000002c0  {
000002c0      [0x0] = 
000002c0      {
000002c0          uint32_t st_name = 0x0
000002c4          uint8_t st_info = 0x0
000002c5          uint8_t st_other = 0x0
000002c6          uint16_t st_shndx = 0x0
000002c8          uint64_t st_value = 0x0
000002d0          uint64_t st_size = 0x0
000002d8      }
000002d8      [0x1] = 
000002d8      {
000002d8          uint32_t st_name = 0x9d
000002dc          uint8_t st_info = 0x12
000002dd          uint8_t st_other = 0x0
000002de          uint16_t st_shndx = 0x0
000002e0          uint64_t st_value = 0x0
000002e8          uint64_t st_size = 0x0
000002f0      }
000002f0      [0x2] = 
000002f0      {
000002f0          uint32_t st_name = 0xce
000002f4          uint8_t st_info = 0x20
000002f5          uint8_t st_other = 0x0
000002f6          uint16_t st_shndx = 0x0
000002f8          uint64_t st_value = 0x0
00000300          uint64_t st_size = 0x0
00000308      }
00000308      [0x3] = 
00000308      {
00000308          uint32_t st_name = 0x54
0000030c          uint8_t st_info = 0x12
0000030d          uint8_t st_other = 0x0
0000030e          uint16_t st_shndx = 0x0
00000310          uint64_t st_value = 0x0
00000318          uint64_t st_size = 0x0
00000320      }
</code></pre><p>The first entry is always all 0. So the first entry has index 0x1. Field <code>st_name</code> does not store the string itself. Instead, it stores the offset into the string table that we discussed earlier. Each name is null-terminated. Given the value 0x9d, we can find out that is <code>free</code>. <code>st_info</code> contains the symbol type that we will not cover in detail here. Now that we connect symbols with its name, we still have no idea which PLT entry corresponds to which symbol. And that is the last part of the mystery.</p>
<p>There are two relocation tables. The first one is <code>DT_RELA</code> and it starts at 0x680 and has a size 0x108. The second one is <code>DT_JMPREL</code>. It starts at 0x788 and it has a size 0x168. Both of them are arrays of <code>Elf64_Rela</code> which is defined as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>
{
  Elf64_Addr    r_offset;       <span style="color:#75715e">/* Address */</span>
  Elf64_Xword   r_info;         <span style="color:#75715e">/* Relocation type and symbol index */</span>
  Elf64_Sxword  r_addend;       <span style="color:#75715e">/* Addend */</span>
} Elf64_Rela;
</code></pre></div><p>The first 4 entries are listed here:</p>
<pre><code>00000788  struct Elf64_Rela _.rela.plt[15] = 
00000788  {
00000788      [0x0] = 
00000788      {
00000788          uint64_t r_offset = 0x201f60
00000790          uint64_t r_info = 0x100000007
00000798          int64_t r_addend = 0x0
000007a0      }
000007a0      [0x1] = 
000007a0      {
000007a0          uint64_t r_offset = 0x201f68
000007a8          uint64_t r_info = 0x300000007
000007b0          int64_t r_addend = 0x0
000007b8      }
000007b8      [0x2] = 
000007b8      {
000007b8          uint64_t r_offset = 0x201f70
000007c0          uint64_t r_info = 0x400000007
000007c8          int64_t r_addend = 0x0
000007d0      }
000007d0      [0x3] = 
000007d0      {
000007d0          uint64_t r_offset = 0x201f78
000007d8          uint64_t r_info = 0x500000007
000007e0          int64_t r_addend = 0x0
000007e8      }
000007e8      [0x4] = 
000007e8      {
000007e8          uint64_t r_offset = 0x201f80
000007f0          uint64_t r_info = 0x700000007
000007f8          int64_t r_addend = 0x0
00000800      }
</code></pre><p>Taking the first entry as an example, the <code>r_offset</code> is 0x201f60. Where is this address? Going back to the DYNAMIC segment, we see that <code>DT_PLTGOT</code> is 0x201f48. This means the PLT starts at 0x201f48.</p>
<p><img src="../imgs/8.png" alt=""></p>
<p>We know the first three entries of PLT have special uses so the first item the compiler tends to use is the fourth one. Now the last problem is which function does the first entry corresponds to.</p>
<p>The secret is in the <code>r_info</code>, which has a value of 0x100000007. There are three macros related to it:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#75715e">#define ELF64_R_SYM(i)          ((i) &gt;&gt; 32)
</span><span style="color:#75715e">#define ELF64_R_TYPE(i)         ((i) &amp; 0xffffffff)
</span><span style="color:#75715e">#define ELF64_R_INFO(sym,type)      ((((Elf64_Xword) (sym)) &lt;&lt; 32) + (type))
</span></code></pre></div><p>The low dword is 7, which specifies the type of relocation entry. and the high dword is 1, which means that the current relocation entry corresponds to the no.1 entry in the symbol table. Remember the No.0 entry is always 0 and we already mentioned that the no.1 entry is <code>free()</code>, so we can rename it to <code>free</code> right now.</p>
<p>This binary is small so I manually resolved all the names like this. But if the binary is large and has many import functions, it is also not hard to write a Python script to resolve them automatically. It looks like this after I finish them.</p>
<p><img src="../imgs/9.png" alt=""></p>
<p>And we now know what is happening in <code>main()</code>.</p>
<p><img src="../imgs/10.png" alt=""></p>
<h2 id="solve-it-finally">Solve it, finally!</h2>
<p>Not that we have passed the most difficult part of the challenge. We still have to reverse the algorithm and solve the challenge itself. The first thing I notice is there is a <code>ptrace</code> based anti-debug:</p>
<p><img src="../imgs/11.png" alt=""></p>
<p>Since there is no integrity check on the binary, I simply patched to <code>Never Branch</code> so it never gets to the failure path.</p>
<p>The next challenge is <code>gdb</code> cannot properly debug it. It cannot even find and set a breakpoint at <code>__libc_start_main</code>. Even if we use the actual address of _start, which is the entry point of the binary, it still malfunctions. I do not have even time to debug why gdb fails, but I managed to find a workaround. I patched an instruction (near the _start) to 0xcc (int3), so it will break and gdb manages to catch it (thx!), we can start debugging from there.</p>
<p>The underlying algorithm is not complex so we will skip it here.</p>
<h2 id="lazy-symbols">Lazy Symbols</h2>
<p>Now that we have explained how non-lazy symbols are resolved. Many materials explain how lazy symbols are resolved. Note the way that the two types of symbols are resolved differently. Lazy symbols are not resolved in a slightly different way. We will recap how they differ and discuss what are some consequences.</p>
<p><img src="../imgs/12.png" alt=""></p>
<p>So the call to <code>time()</code> in the <code>main()</code> function actually first calls into a stub function. The qword at <code>time_GOT</code> is 0x986, and the code at 0x986 is:</p>
<p><img src="../imgs/13.png" alt=""></p>
<p>Now we see the <code>push 0x6</code> and the <code>jmp</code> which is covered in lots of writeups about PLT/GOT. 0x6 is also the index into the relocation table that helps the loader resolve the import. We all know that lazy-symbols are not resolved at load-time. When the program calls it for the first time, the index (0x6) is pushed onto the stack before the code gets to <code>_dl_runtime_resolve()</code>. Note this <code>push n</code> is ONLY used for lazy symbols. For non-lazy ones, the loader uses the information in <code>Elf64_Rela-&gt;r_info</code> to resolve the imports. By the time the import function is called for the first time, the value at <code>time_GOT</code> is already the actual address of time() in <code>libc.so</code> and NOT 0x986. So the code in the above screenshot is never executed. You can patch it to <code>int 3</code> to test it. However, for lazy symbols, where the <code>push n</code> plays a role, if we do the same patch, the program will crash during loading.</p>
<p>To sum up, non-lazy symbols directly use the index in <code>Elf64_Rela-&gt;r_info</code> and lazy-symbols use index in the <code>push n</code> to the first index into the relocation table, and then use <code>Elf64_Rela-&gt;r_info</code> to continue the resolution.</p>
<p>Thus, to obfuscate the binary, we can change the value of <code>push n</code> and make it point to a different symbol. Since it seems current tools all use <code>Elf64_Rela-&gt;r_info</code> to retrieve the index value into the symbol table. So there is an opportunity to create a binary that executes as expected, but cannot be properly analyzed by reverse engineering tools. I will update this writeup when I have a concrete example.</p>
<p>For reverse engineering tools, the best way to defeat this obfuscation is to distinguish lazy/non-lazy symbols and parse the <code>push n</code> for lazy symbols and obtain the index accordingly. But this creates several issues since they typically do not only support x86/x64, they have to also support other architectures like ARM. There are going to be some nuances that inflate the code logic so it is not simple to do.</p>
<h2 id="references">References</h2>
<p>There are many references that I used during writing. Unfortunately, I did not mark it when I referenced them. Instead, I assembled a list and put it here:</p>
<ul>
<li><code>elf.h</code> in Linux source code</li>
<li>Book <code>&quot;Learning Linux Binary Analysis&quot;</code></li>
<li><a href="https://ypl.coffee/dl-resolve/">Understanding _dl_runtime_resolve</a></li>
<li><a href="http://michalmalik.github.io/elf-dynamic-segment-struggles">ELF: dynamic struggles</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Making and solving a Reversing Challenge Based-on x86 ISA Encoding</title>
            <link>/posts/reversing/x86/readme/</link>
            <pubDate>Sun, 02 Aug 2020 00:00:00 +0000</pubDate>
            
            <guid>/posts/reversing/x86/readme/</guid>
            <description>This time the writeup is a little bit different &amp;ndash; I am the maker of this challenge so the narrative is from a different perspective. I will first cover how I made it, and then show two possible ways to solve it.
The Plan I have always been hoping to make some reversing challenges based-on the encoding of the x86 instruction set. It does not have to be super hard, maybe just explore some interesting aspects of the x86, which goes lower than the disassembly.</description>
            <content type="html"><![CDATA[<p>This time the writeup is a little bit different &ndash; I am the maker of this challenge so the narrative is from a different perspective. I will first cover how I made it, and then show two possible ways to solve it.</p>
<h2 id="the-plan">The Plan</h2>
<p>I have always been hoping to make some reversing challenges based-on the encoding of the x86 instruction set. It does not have to be super hard, maybe just explore some interesting aspects of the x86, which goes lower than the disassembly. Recently, thanks to my intern task that lifts x86 instructions, as well as reading this <a href="https://www.msreverseengineering.com/blog/2015/6/9/x86-trivia-for-nerds">blog post</a>, I decided to do it rather than set it for the future (indefinitely).</p>
<p>There are several ways to do it, and I think it is not a bad idea to mutate the executable code according to the user input. It is interesting because, for most reversing challenges, the solver is not expected to change (patch) the code. However, we can take the user input and explicitly use it, in certain ways, to modify the code.</p>
<p>So how do we do it? Executing the user input directly is probably not a good idea. Since code is typically non-printable, so the solution is going to be ugly. More importantly, when we grant the player with arbitrary code execution, it is hard to enforce that they solve it in our intended way.</p>
<p>So it is best to modify existing code according to the user input. The first thing that came to my mind is we can do some arithmetics with it. We can have an equation like:</p>
<pre><code>start_value ± a1 ± a2 ± .. ± an == result
</code></pre><p>Where the user has to figure out the correct plus or minus sign to make this equation correct. The <code>start_value</code>, <code>result</code>, as well as the <code>ai</code> (1 &lt;= i &lt;= n), are all randomly generated. I made them 32-bit integers.</p>
<h2 id="implementing-and-automating">Implementing and Automating</h2>
<p>There are a couple of things to make the idea concrete.</p>
<p>Firstly, how do we accept the user inputs? We can directly take plus or minus signs as string literals but I wish to make it slightly twisted here: the program will take a 32-bit integer and use each of its bits as the indicator of plus/minus.</p>
<p>The next thing is about the x86 instruction encoding. I decided to use the register <code>eax</code> to hold the accumulated value and eventually compare it with the target value. We know that x86 instruction encodes the opcode in a straight-forward way, so it is quite easy to switch between an add instruction and sub instruction.</p>
<p><img src="../imgs/1.png" alt=""></p>
<p>If you look at the highlighted line, you will notice that <code>ADD EAX, imm32</code> is encoded as <code>05 id</code>, where the <code>05</code> stands for the opcode, and the <code>id</code> means a 32-bit immediate follows it. So if we have bytes <code>0512345678</code>, it will decode to <code>ADD EAX, 0x78563412</code> (note the endianess). Similarly, <code>SUB EAX, imm32</code> is encoded as <code>2D id</code>. So the real difference between an <code>ADD EAX, imm32</code> and a <code>SUB EAX, imm32</code> is the opcode, i.e., the first byte of the instruction.</p>
<p>So the code modifying is easy: we just need to check every bit of the user input and overwrite the opcode byte of the correct one (05 or 2D). Each instruction is 5 bytes and the latter four bytes encode the immediate value in the equation.</p>
<p>This challenge can be made manually, but I prefer to be able to generate it automatically. That brings several benefits, e.g., the ease of debugging during development. The source code of the challenge is provided in the <a href="../source.zip">source folder</a>, and you can have a look at it.</p>
<p>The code that does not change is written in C, whereas a Python script will generate random constant values for the changes and write it to a .h header file. the header file is included in the C source file so it can compile end-to-end. I also make a Makefile so I can easily build debug and release version of it. The Python generator looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#f92672">import</span> random
<span style="color:#f92672">import</span> os

rounds <span style="color:#f92672">=</span> <span style="color:#ae81ff">32</span>
MAXINT <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xffffffff</span>

output <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#39;code.h&#39;</span>, <span style="color:#e6db74">&#39;w&#39;</span>)

val <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span>randint(<span style="color:#ae81ff">0</span>, MAXINT)
<span style="color:#75715e"># mov eax, val</span>
output<span style="color:#f92672">.</span>write(<span style="color:#e6db74">&#39;{0xb8, 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">},</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> val)
ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(rounds):
    op <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span>randint(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>)
    round_val <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span>randint(<span style="color:#ae81ff">0</span>, MAXINT)
    ans <span style="color:#f92672">|=</span> (op <span style="color:#f92672">&lt;&lt;</span> i)
    <span style="color:#66d9ef">if</span> op <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
        val <span style="color:#f92672">-=</span> round_val
    <span style="color:#66d9ef">else</span>:
        val <span style="color:#f92672">+=</span> round_val

    val <span style="color:#f92672">&amp;=</span> MAXINT
    
    junk_opcode <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span>randint(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0xff</span>)
    output<span style="color:#f92672">.</span>write(<span style="color:#e6db74">&#39;{0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">, 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">},</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> (junk_opcode, round_val))

<span style="color:#75715e"># cmp eax, val</span>
output<span style="color:#f92672">.</span>write(<span style="color:#e6db74">&#39;{0x3d, 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">},&#39;</span> <span style="color:#f92672">%</span> val)
output<span style="color:#f92672">.</span>close()

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;the answer is: </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> ans)
os<span style="color:#f92672">.</span>system(<span style="color:#e6db74">&#39;make&#39;</span>)
</code></pre></div><p>The C source file defines a struct to describe the two particular instructions we are using:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#75715e">#pragma pack(1) 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>
{
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> opCode;
    uint32_t operand;
}instr;
</code></pre></div><p>The main.c is the core part of the challenge:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#75715e">#define N 32
</span><span style="color:#75715e"></span>
instr code[]  __attribute__ ((section (<span style="color:#e6db74">&#34;.x86&#34;</span>))) <span style="color:#f92672">=</span> {
    <span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;code.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    {<span style="color:#ae81ff">0x0f</span>, <span style="color:#ae81ff">0x9090d094</span>},         
    <span style="color:#75715e">// 00201043  0f94d0             sete    al  {0x1}
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 00201046  90                 nop     
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 00201047  90                 nop     
</span><span style="color:#75715e"></span>    {<span style="color:#ae81ff">0xc3</span>, <span style="color:#ae81ff">0</span>}
    <span style="color:#75715e">// 00201048  c3                 retn     {__return_addr}
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#75715e">// read the input
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> input <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> unused <span style="color:#f92672">=</span> scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>input);
    <span style="color:#75715e">// modify the code according to the user input
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i <span style="color:#f92672">++</span>)
    {
        <span style="color:#66d9ef">bool</span> bit <span style="color:#f92672">=</span> input <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>;
        input <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span> (bit)
        {
            <span style="color:#75715e">// add eax, imm32
</span><span style="color:#75715e"></span>            code[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>].opCode <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x05</span>;
        }
        <span style="color:#66d9ef">else</span>
        {
            <span style="color:#75715e">// sub eax, imm32
</span><span style="color:#75715e"></span>            code[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>].opCode <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x2d</span>;
        }
    }
    <span style="color:#75715e">// set page to executable
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>page <span style="color:#f92672">=</span>
     (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) ((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) (<span style="color:#f92672">&amp;</span>code) <span style="color:#f92672">&amp;</span>
        <span style="color:#f92672">~</span>(getpagesize() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
    mprotect(page, getpagesize(), PROT_READ <span style="color:#f92672">|</span> PROT_WRITE <span style="color:#f92672">|</span> PROT_EXEC);

    <span style="color:#75715e">// call the code and check result
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> (<span style="color:#f92672">*</span>func_ptr)() <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>code;
    <span style="color:#66d9ef">if</span> (func_ptr())
    {
        printf(<span style="color:#e6db74">&#34;Well done!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    }
    <span style="color:#66d9ef">else</span>
    {
        printf(<span style="color:#e6db74">&#34;Try again!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    }
}
</code></pre></div><h2 id="solving-it-with-z3">Solving it with Z3</h2>
<p>Now it is time to solve it. A dull brute-force solves it, though it could take a while to complete. The most straightforward idea is to use Z3. We create 32 booleans and transcribe the calculations into Z3 syntax. Of course, we need to extract those constant values, but it should be relatively easy. Then I get:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#f92672">from</span> z3 <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>

<span style="color:#75715e"># extracted from the challenge binary</span>
init_val <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x3df2f794</span>
target_val <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x7a612770</span>
constants <span style="color:#f92672">=</span> [
    <span style="color:#ae81ff">0x52ae22f2</span>,
    <span style="color:#ae81ff">0xbf409bcc</span>,
    <span style="color:#ae81ff">0x46417dc1</span>,
    <span style="color:#ae81ff">0x25f7d9a1</span>,
    <span style="color:#ae81ff">0xef83a7ce</span>,
    <span style="color:#ae81ff">0x2dd63e8e</span>,
    <span style="color:#ae81ff">0x584a1ec5</span>,
    <span style="color:#ae81ff">0x8e58e1df</span>,
    <span style="color:#ae81ff">0xf2705f70</span>,
    <span style="color:#ae81ff">0x2e94ef1e</span>,
    <span style="color:#ae81ff">0x3ca9e080</span>,
    <span style="color:#ae81ff">0xa617b5df</span>,
    <span style="color:#ae81ff">0x29ae9c3d</span>,
    <span style="color:#ae81ff">0x7461ed52</span>,
    <span style="color:#ae81ff">0x7125faac</span>,
    <span style="color:#ae81ff">0x65dfffd6</span>,
    <span style="color:#ae81ff">0x97f1f41c</span>,
    <span style="color:#ae81ff">0x6f4e0648</span>,
    <span style="color:#ae81ff">0xd803e5d0</span>,
    <span style="color:#ae81ff">0xf358f0eb</span>,
    <span style="color:#ae81ff">0xbc3b30c7</span>,
    <span style="color:#ae81ff">0x585685f8</span>,
    <span style="color:#ae81ff">0x2a9cc47c</span>,
    <span style="color:#ae81ff">0x7f03d175</span>,
    <span style="color:#ae81ff">0xc1d942ae</span>,
    <span style="color:#ae81ff">0x174c7d4f</span>,
    <span style="color:#ae81ff">0xb7d004f0</span>,
    <span style="color:#ae81ff">0xbec8b077</span>,
    <span style="color:#ae81ff">0x8ce8eaa2</span>,
    <span style="color:#ae81ff">0x2510e330</span>,
    <span style="color:#ae81ff">0x4aed0eee</span>,
    <span style="color:#ae81ff">0x4043cd91</span>
]

<span style="color:#75715e"># solver script</span>
n <span style="color:#f92672">=</span> <span style="color:#ae81ff">32</span>
inputs <span style="color:#f92672">=</span> [Bool(<span style="color:#e6db74">&#39;bit_</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> i) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n)]

val <span style="color:#f92672">=</span> BitVecVal(init_val, <span style="color:#ae81ff">32</span>)
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
    val <span style="color:#f92672">=</span> If(inputs[i], val <span style="color:#f92672">+</span> constants[i], val <span style="color:#f92672">-</span> constants[i])

s <span style="color:#f92672">=</span> Solver()
s<span style="color:#f92672">.</span>add(val <span style="color:#f92672">==</span> BitVecVal(target_val, <span style="color:#ae81ff">32</span>))

<span style="color:#66d9ef">if</span> s<span style="color:#f92672">.</span>check() <span style="color:#f92672">==</span> sat:
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;solved&#39;</span>)
    m <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span>model()
    solution <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
        bit <span style="color:#f92672">=</span> m<span style="color:#f92672">.</span>evaluate(inputs[i])
        <span style="color:#66d9ef">if</span> bit:
            solution <span style="color:#f92672">|=</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> i)
    <span style="color:#66d9ef">print</span>(solution)
<span style="color:#66d9ef">else</span>:
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;failed&#39;</span>)
</code></pre></div><p>It works but it is a little bit slow. It took 5 minutes to solve it, IIRC. The solution I get is:</p>
<pre><code>$ python z3_solve.py 
solved
2371132652
</code></pre><p>And it works:</p>
<pre><code>$ ./x86
2371132652
Well done!
</code></pre><p>Interestingly, the solution found by Z3 is different from the seed I used to generate the challenge, which is <code>1804139300</code>. But this is not surprising since there could exist other solutions than the original one. And I did not do anything to enforce the uniqueness of the challenge.</p>
<h2 id="solving-it-with-divide-and-conquer">Solving it with Divide-and-Conquer</h2>
<p>Z3 is good enough. However, there is another way to solve it. We can use divide-and-conquer to accelerate the brute-force. We can try the first 16 bits, which make up (2 ^ 16 = 65536) possibilities. We take note of the values we get. After that, we do the same thing for the latter 16 bits and do the same. Now we compare the two sets and compare if there are any matches. This allows us to find solutions in a faster way. Also, this can help us find ALL the solutions to this challenge.</p>
<p>I am too lazy to do it by myself. I will leave it for interested readers!</p>
]]></content>
        </item>
        
        <item>
            <title>Solving a Recursive Crackme by Automating GDB</title>
            <link>/posts/reversing/automating-gdb/readme/</link>
            <pubDate>Mon, 27 Jul 2020 00:00:00 +0000</pubDate>
            
            <guid>/posts/reversing/automating-gdb/readme/</guid>
            <description>The last week&amp;rsquo;s challenge is called Recursion. From the name we already expect to do some automation &amp;ndash; manually solving stuff recursively is not a wise idea.
First Impression The forum probably does not allow users to post binary files, so challenges are all posted as base64 encoded. There are too many ways to restore the binary, but Binary Ninja saves you from remembering the command: Just copy the encoded text, create a new empty binary, and then click &amp;ldquo;Paste From&amp;rdquo; -&amp;gt; &amp;ldquo;Base64&amp;rdquo;.</description>
            <content type="html"><![CDATA[<p>The last week&rsquo;s challenge is called <a href="https://0x00sec.org/t/reverseme-recursion/21802"><code>Recursion</code></a>. From the name we already expect to do some automation &ndash; manually solving stuff recursively is not a wise idea.</p>
<h2 id="first-impression">First Impression</h2>
<p>The forum probably does not allow users to post binary files, so challenges are all posted as base64 encoded. There are too many ways to restore the binary, but Binary Ninja saves you from remembering the command: Just copy the encoded text, create a new empty binary, and then click &ldquo;Paste From&rdquo; -&gt; &ldquo;Base64&rdquo;. Then you are done!</p>
<p><img src="../imgs/1.png" alt=""></p>
<p>We get a 14.5 kB ELF file. There is some mild obfuscation in the start of the <code>main</code>, which does not pose a serious challenge. In the middle of the <code>main</code> we see the program is reading input and checking length:</p>
<p><img src="../imgs/2.png" alt=""></p>
<p>The first thing I notice is that the input must be exactly 0x50 chars, which is quite unusual. Not it reads at most 0x50 chars and checks if the chars read are at least 0x50 chars, which means it must be 0x50 chars.</p>
<p>Besides, after the length check, we see it calls <code>mmap</code>. For reversing challenges, once we see a <code>mmap</code> in it, probably there is a self-modifying code.</p>
<p><img src="../imgs/3.png" alt=""></p>
<p>Moving downward we see that the program copies a 0xae4-byte buffer into the newly allocated buffer, and then calls it. A strange thing here is the user input is moved into register <code>r12</code>. Typically, no compilers will use register <code>r12</code> to pass function argument, so this code might be hand-crafted.</p>
<p>After the <code>call rdx</code>, the program tells if the flag is correct based on the return value. Now the next step is obvious, we need to define a function on that code buffer and see what it has.</p>
<h2 id="decryption-routine">Decryption routine</h2>
<p><img src="../imgs/4.png" alt=""></p>
<p>The function looks like this. The loop decrypts another buffer at <code>data_20ab</code>, whose size is 0xa59. The decryption is just xor with 0x9f. Note the code_size variable sits right after this function, and right before the next data buffer to be decrypted. Meanwhile, the loop calculates a checksum of the next data buffer, and compare it with the dword at register <code>r12</code>. What is it? It is the user input! So the user input must match the checksum value.</p>
<p>If the checksum matches, the program continues to execute the second newly decrypted buffer. Here, we can use Binary Ninja&rsquo;s transformation to transform the data in place, after which we define a function at the start of it.</p>
<p><img src="../imgs/5.png" alt=""></p>
<p>The newly defined function looks like this:</p>
<p><img src="../imgs/6.png" alt=""></p>
<p>It looks almost the same as the previous one, except for some small mutations. The xor key is different and it is 0xb6 this time. The buffer size is 0x9ce this time, which is smaller than the previous one. And that indicates we are probably recursively decrypting this buffer and each time we only decrypt the first part of it, which forms a function.</p>
<p>I tried to repeat the process a few times and it just repeats. RECURSION. That is probably a good reason for the name.</p>
<p>The first way to solve this is to solve it statically. We only need to get the xor key and the buffer size, to decrypt the buffer and calculate the checksum. However, due to the mutation, it is not that easy to get it correct. It is, though, definitely possible, but not optimal. So I come up with a dynamic approach.</p>
<h2 id="using-hardware-breakpoints-and-automating-gdb">Using Hardware Breakpoints and Automating GDB</h2>
<p>I did not rewrite the checksum algorithm by myself, despite it is super simple. Even if it is super complex and I cannot reverse/rewrite it, I can still solve this challenge. Why?</p>
<p>Because we can wait at the line where the dword from the user input is compared with the correct checksum. Particularly, it is the <code>cmp esi, edi</code> line. the register <code>esi</code> holds our input, which, during debugging, is trash. Register <code>edi</code> holds the correct checksum. If we set a breakpoint here and examine the value of <code>edi</code>, we directly get the correct checksum.</p>
<p>However, this approach cannot easily scale to the entire challenge. The problem here is we do not know where to set the next breakpoint before we decrypt the code. However, manually decrypting the code is arduous and error-prone, so we would better automate the solution.</p>
<p>Note the address of the user input buffer is moved into r12 and never changed. If one checksum matches, the program executes <code>add r12, 0x4</code> to move to the next dword. So we can use a hardware breakpoint to catch the program when it reads the buffer <code>r12</code>, and read the value of <code>edi</code>. Then we remove the current hardware breakpoint, set a new one on the next address, and wait for the program to break again.</p>
<p>Automating GDB is easier said than done. I have known it is possible for a long time, though I have never done it before. After duckduckgo-ing a little bit, I found there are two ways to do it. The first one is to implement a GDB command in Python; the second way is to use pygdbmi to interact with GDB&rsquo;s machine interface.</p>
<p>Both methods allow us to execute gdb commands as if we directly use GDB, and get the output from GDB afterward. However, I found the pygdbmi approach is much harder to use for the current purpose. First of all, it runs GDB headlessly. So if there is an error in the script, it is hard to find it. Conversely, if we take the first approach, since we register ourselves as a new command (<code>solve</code> in particular) after we run the stuff we are still in GDB. We can see the commands we executed and see the outputs from GDB, which allows painless debugging. Also, despite the name machine interface, it does not automatically parse the string output from GDB. For example, if we examine the value of <code>rdi</code> by executing</p>
<p><code>p/x $rdi</code></p>
<p>The GDB returns something like:</p>
<p><code>$1 = 0x555555557e90</code></p>
<p>I would expect the pygdbmi to parse the value for me. However, it does nothing for this and directly returns the string output. We get the very same thing in the first approach. So obviously it is the better way to do it.</p>
<p>Note that I am not saying gdbmi is not good. It is used by various projects, e.g., gdbgui, which is a browser-based GDB frontend. If you have not tried it, I strongly recommend you to experiment with it. It is just using gdbmi will require more development work and it is not suitable for reversing challenge, where we care more about getting things rolling faster.</p>
<p>Ok, so much for the comparison. It is time to get to the code. The code is not fancy &ndash; it just requires some effort to write it correctly.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#f92672">import</span> gdb
<span style="color:#f92672">import</span> struct

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_reg_value</span>(response):
    response <span style="color:#f92672">=</span> response<span style="color:#f92672">.</span>split()[<span style="color:#ae81ff">2</span>]
    value <span style="color:#f92672">=</span> int(response, <span style="color:#ae81ff">16</span>)
    <span style="color:#66d9ef">return</span> value
    
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solve</span>(gdb<span style="color:#f92672">.</span>Command):
    <span style="color:#66d9ef">def</span> __init__(self):
        <span style="color:#75715e"># This registers our class as &#34;solve&#34;</span>
        super(Solve, self)<span style="color:#f92672">.</span>__init__(<span style="color:#e6db74">&#34;solve&#34;</span>, gdb<span style="color:#f92672">.</span>COMMAND_DATA)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">invoke</span>(self, arg, from_tty):
        <span style="color:#75715e"># When we call &#34;solve&#34; from gdb, this is the method</span>
        <span style="color:#75715e"># that will be called.</span>

        dummy_input <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#39;input.txt&#39;</span>, <span style="color:#e6db74">&#39;wb&#39;</span>)
        dummy_input<span style="color:#f92672">.</span>write(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;1&#39;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x50</span>)
        dummy_input<span style="color:#f92672">.</span>close()

        solution <span style="color:#f92672">=</span> bytes()

        inferiors <span style="color:#f92672">=</span> gdb<span style="color:#f92672">.</span>inferiors()
        inferior <span style="color:#f92672">=</span> inferiors[<span style="color:#ae81ff">0</span>]
        gdb<span style="color:#f92672">.</span>execute(<span style="color:#e6db74">&#39;del&#39;</span>)
        gdb<span style="color:#f92672">.</span>execute(<span style="color:#e6db74">&#39;file crackme.elf&#39;</span>)
        gdb<span style="color:#f92672">.</span>execute(<span style="color:#e6db74">&#39;set breakpoint pending on&#39;</span>)
        gdb<span style="color:#f92672">.</span>execute(<span style="color:#e6db74">&#39;b __libc_start_main&#39;</span>)
        gdb<span style="color:#f92672">.</span>execute(<span style="color:#e6db74">&#39;r &lt; input.txt&#39;</span>)
        response <span style="color:#f92672">=</span> gdb<span style="color:#f92672">.</span>execute(<span style="color:#e6db74">&#39;p/x $rdi&#39;</span>, to_string <span style="color:#f92672">=</span> True)
        main_addr <span style="color:#f92672">=</span> get_reg_value(response)
        main_addr_raw <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x1229</span>
        <span style="color:#66d9ef">print</span>(main_addr)
        base <span style="color:#f92672">=</span> main_addr <span style="color:#f92672">-</span> main_addr_raw

        gdb<span style="color:#f92672">.</span>execute(<span style="color:#e6db74">&#39;b *</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> (base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x1399</span>))
        gdb<span style="color:#f92672">.</span>execute(<span style="color:#e6db74">&#39;c&#39;</span>)

        response <span style="color:#f92672">=</span> gdb<span style="color:#f92672">.</span>execute(<span style="color:#e6db74">&#39;p/x $rax&#39;</span>, to_string <span style="color:#f92672">=</span> True)
        input_addr <span style="color:#f92672">=</span> get_reg_value(response)
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;input_addr&#39;</span>, hex(input_addr))
        
        i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">while</span> True:
            <span style="color:#66d9ef">try</span>:
                gdb<span style="color:#f92672">.</span>execute(<span style="color:#e6db74">&#39;del&#39;</span>)
                gdb<span style="color:#f92672">.</span>execute(<span style="color:#e6db74">&#39;rwatch *</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> (input_addr <span style="color:#f92672">+</span> i <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span>))
                gdb<span style="color:#f92672">.</span>execute(<span style="color:#e6db74">&#39;c&#39;</span>)

                response <span style="color:#f92672">=</span> gdb<span style="color:#f92672">.</span>execute(<span style="color:#e6db74">&#39;p/x $edi&#39;</span>, to_string <span style="color:#f92672">=</span> True)
                checksum <span style="color:#f92672">=</span> get_reg_value(response)
                <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;checksum&#39;</span>, hex(checksum))
                solution <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#39;&lt;I&#39;</span>, checksum)
                
                gdb<span style="color:#f92672">.</span>execute(<span style="color:#e6db74">&#39;set $rsi = </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> checksum)
                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">except</span>:
                <span style="color:#66d9ef">break</span>

        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;=&#39;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">50</span>)
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;the flag is:&#39;</span>)
        <span style="color:#66d9ef">print</span>(solution)
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;len:&#39;</span>, len(solution))

        output <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#39;solution.txt&#39;</span>, <span style="color:#e6db74">&#39;wb&#39;</span>)
        output<span style="color:#f92672">.</span>write(solution)
        output<span style="color:#f92672">.</span>close()


<span style="color:#75715e"># This registers our class to the gdb runtime at &#34;source&#34; time.</span>
Solve()
</code></pre></div><p>To use it,</p>
<ol>
<li>run gdb</li>
<li>inside gdb, run <code>source gdb_solve.py</code></li>
<li>inside gdb, run <code>solve</code></li>
<li>after it runs, it should print the solution and also write it to solution.txt</li>
<li>verify it by <code>cat solution.txt | ./crackme.elf</code></li>
</ol>
<p>Which is quite simple, isn&rsquo;t it? Maybe the command <code>rwatch</code> is new, which sets hardware read/write breakpoints.</p>
<p>The correct flag contains non-printable chars, which is not surprising, as it is unlikely the checksum of the code happens to be a printable string. Unless the maker put some effort to make it that way.</p>
<p>In the above script, there is one thing to point out. We run</p>
<p><code>set breakpoint pending on</code></p>
<p>before</p>
<p><code>b __libc_start_main</code>.</p>
<p>This is because, if we do not do it, the attempt to set a breakpoint on <code>__libc_start_main</code> will produce an error. And it only happens before we run the binary. So in other words, if we first run the binary in GDB for at least once, and then directly set a breakpoint on <code>__libc_start_main</code>, it will succeed. That is because GDB has seen that function once, and it knows to wait for it. However, since we are automating GDB, every time it bootstraps cleanly and it does not know there exists a <code>__libc_start_main</code>, hence the error. I am not familiar enough with the GDB source code so I cannot speculate why it happens, but probably there are some reasons behind it. Anyway, <code>set breakpoint pending on</code> is the correct way to deal with it.</p>
<p>The author also released his/her own <a href="https://0x00sec.org/t/reverseme-recursion/21802/4?u=xusheng">writeup</a>, which needs to be decrypted by the correct flag. I suggest you to have a look at it, espcially the mutation part.</p>
]]></content>
        </item>
        
        <item>
            <title>Solving an Obfuscated Crackme with BinaryNinja and Triton</title>
            <link>/posts/reversing/obfuscation/readme/</link>
            <pubDate>Thu, 02 Jul 2020 00:00:00 +0000</pubDate>
            
            <guid>/posts/reversing/obfuscation/readme/</guid>
            <description>The last week&amp;rsquo;s challenge was created by Dennis Yurichev. It is also hosted on crackmes.one. The challenge is compiled by a modified Tiny C Compiler (TCC) which obfuscates the generated code during compilation. We will cover the major techniques to deobfuscate the binary, followed by a quick analysis of the algorithm itself.
First Impression The target (keygenme4.exe) is a PE. The entry point looks like this:
There are several things which we can notice easily:</description>
            <content type="html"><![CDATA[<p>The last week&rsquo;s <a href="https://yurichev.com/blog/58/">challenge</a> was created by <a href="https://yurichev.com/">Dennis Yurichev</a>. It is also hosted on <a href="https://crackmes.one/crackme/5ab77f6233c5d40ad448c9e4">crackmes.one</a>. The challenge is compiled by a modified <a href="https://bellard.org/tcc/">Tiny C Compiler (TCC)</a> which obfuscates the generated code during compilation. We will cover the major techniques to deobfuscate the binary, followed by a quick analysis of the algorithm itself.</p>
<h2 id="first-impression">First Impression</h2>
<p>The target (<a href="../keygenme4.exe">keygenme4.exe</a>) is a PE. The entry point looks like this:</p>
<p><img src="../imgs/1.png" alt=""></p>
<p>There are several things which we can notice easily:</p>
<ol>
<li>The basic block is quite long.</li>
<li>It has excessive amounts of continuous arithmetic operations.</li>
</ol>
<ol>
<li>is quite common for obfuscated code. Several obfuscation techniques inflate the code and make it hard to read. 2. is unique to this obfuscator. If we look at the following instructions closely, we notice it is first loading a constant into <code>eax</code>, does a series of arithmetic operations on it, and saving it to a variable.</li>
</ol>
<pre><code>0041af0a  mov     eax, dword [data_41c1b4]
0041af10  shr     eax, 0x0
0041af13  shr     eax, 0x1
0041af16  xor     eax, 0xa8f3a9ca
0041af1c  shl     eax, 0x7
0041af1f  sub     eax, 0x5a041880
0041af25  mov     dword [ebp-0x14 {var_18}], eax
</code></pre><p>After we check the dword value at data_41c1b4, we can emulate the above code snippet and find out the final value of <code>eax</code>. It turns out to be 0. So the code is equivalent to:</p>
<pre><code>0041af25  mov     dword [ebp-0x14 {var_18}], 0x0
</code></pre><p><code>data_41c1b4</code> is a global variable. When we click on it, we can see all its cross-references. After browsing the list we find that the value is read a lot of time, but it is never written to.</p>
<p><img src="../imgs/9.png" alt=""></p>
<p>This means the value never changes. And sequence of instructions like the above one can be simplified to just one constant load.</p>
<p>We will call this <code>convoluted constant load</code> later on. Not bad, we break one of the obfuscation! Well, not yet. We just understand how it works and solves it manually. But we need to solve them automatically. <code>Automation</code> is an important topic in deobfuscation. Often the obfuscation is not hard to understand, but solving them can be much harder. We will discuss how to tackle it later.</p>
<h2 id="hunting-for-other-obfuscation-techniques">Hunting for Other Obfuscation Techniques</h2>
<p>As we explore the binary, we can find the following obfuscation techniques.</p>
<h3 id="obfuscated-calls">Obfuscated Calls</h3>
<p><img src="../imgs/2.png" alt=""></p>
<p>0x41c0fa is the string to be printed by <code>printf</code>, which is nothing special. The next four instructions do the interesting stuff:</p>
<pre><code>00416db8  call    $+5 {var_c}  {data_416dbd}
00416dbd  pop     eax {var_c}
00416dbe  add     eax, 0xa  {sub_416dc7}
00416dc1  push    eax {var_c}  {sub_416dc7}
</code></pre><p>After the <code>call $+5</code>, the <code>eip</code> becomes 0x416dbd. Meanwhile, the return address is pushed onto the top of the stack. Note the return address is also 0x416dbd. The following <code>pop, add, push</code> sequence would change the return address to <code>sub_416dc7</code> (which is also calculated by BinaryNinja).</p>
<p>Now it executes <code>jmp printf</code>. Note this is a <code>jmp</code> so it does not push a return address onto the stack. <code>sub_416dc7</code> is still on the top of the stack. The string to be printed is right below it. In other words, this creates a fake call stack and it manipulates the return address so the code will continue execution from a different place (rather than the code below the printf).</p>
<p>printf has no magic and it just prints the string. When the execution returns from the printf, the return address sub_416dc7 is popped from the stack and executed. In other words, the above code is equivalent to:</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><img src="../imgs/3.png" alt=""></p>
<p>This is not hard to deal with since the pattern is quite obvious. We will cover how to solve it later.</p>
<h3 id="opaque-predicate">Opaque Predicate</h3>
<p><img src="../imgs/6.png" alt=""></p>
<p>Another abnormal thing we notice is the code has an excessive amount of branches. If we look at the code closely, we can see something like this:</p>
<pre><code>00401248  sub     edx, edx  {0x883d6589}  {0x883d6589}
0040124a  jne     0x40120a  {0x0}
</code></pre><p>Thanks to the <code>sub edx, edx</code>, the zero flag is always set thus the jne never jumps. This is more obvious if we switch to the Low-Level IL (LLIL):</p>
<p><img src="../imgs/7.png" alt=""></p>
<p>In other words, the branch is fake and the execution always gets to 0x40124c. We call this an <code>opaque predicate</code>.</p>
<p>Opaque predicate is a well-known obfuscation technique that slows down reversers. When we reverse a piece of code, we often first get a grasp of the behavior of the code by looking at its layout (branches, loops, etc). Even beginners know to look for the critical branch that decides whether the code will print a &ldquo;congratulation&rdquo; or &ldquo;sorry&rdquo;.</p>
<p>Opaque predicate can be removed statically &ndash; since they are opaque and one branch is always taken. However, in real-world, we can use some mathematical fact that is hard to be solved by a program. For example, for any integer <code>x</code>, this is always true:</p>
<pre><code>x * (x + 1) * (x + 2) == 0 (mod 6)
</code></pre><p>If we know the set of opaque predicates the obfuscator use, then we can do a pattern matching. Otherwise, we might need to use z3 to prove it. The good news is, in this particular binary, the opaque predicates are quite easy to deal with.</p>
<h3 id="junk-code-insertion">Junk Code Insertion</h3>
<p>Inserting junk code is another popular obfuscation technique. Check out the following code:</p>
<p><img src="../imgs/5.png" alt=""></p>
<p>It is pretty messy &ndash; which is a sign of useless code. And we see the register <code>edx</code> is overwritten before it is used. By &ldquo;used&rdquo; I mean it is not written to the memory or used to calculate other values.</p>
<p>Junk code insertion is very easy to implement, and not always easy to solve. There is no silver bullet for it, though optimization is the general method to deal with it. Yes, optimization not only helps compiler generate faster code, it also helps remove unnecessary code. For the interested readers, this <a href="https://github.com/JonathanSalwan/Tigress_protection">script</a> uses LLVM to remove the Trigress VM.</p>
<p>However, in this writeup, we will take a different approach. We will leverage some property of the code generated by TCC and solve it by backward taint analysis.</p>
<h2 id="writing-a-deobfuscator">Writing a deobfuscator</h2>
<p>Before I discuss the details of the deobfuscator, I would like to first address the availability of the obfuscator source code. We all know TCC is open-source. And Dennis provided the <a href="http://conus.info/stuff/tcc-obfuscate/tcc-0.9.25-diff">patch file</a>. So we can look at how the obfuscated binary is generated. This is of course a good thing since we can learn from the obfuscator. And I do recommend that everyone read it since it can show a relatively simple and lightweight way of implementing an obfuscating compiler.</p>
<p>However, this also introduces a problem: in the real-world, we typically do not have the source code for the obfuscator. So we should avoid using too many details from it. Though I still use some &ndash; but I try to limit them as few as possible.</p>
<p>Writing a deobfuscator is harder than understanding the obfuscation. I was once hesitant to start tackling this since I know it is going to take a few days. And now when I look at the code I have written, I still remember the hardship that I encountered. But I have succeeded! This is something that I am proud of.</p>
<p>We probably cannot cover every detail of the deobfuscator. It is only 500 LoC but discussing every bit (as well as the reasoning behind it) is beyond the scope of this writeup. But I will cover the major highlights.</p>
<h3 id="planning">Planning</h3>
<p>Writing a good deobfuscator needs some planning before actual coding. The first thing we need to consider is tooling. Binary analysis requires lots of tools to proceed. How do we get the disassembly? What is the processing pipeline?</p>
<p>In this writeup, I use BinaryNinja as the primary tool. It has a powerful Python API so it is quite easy to access the disassembled functions, basic blocks, assembly lines, etc. Later I also used Triton for backward taint analysis, which allows me to remove junk code quite effectively.</p>
<p>The goal is simple: produce deobfuscated code. Note, however, one hurdle here is we do not have the ground truth for the obfuscated binary. As a result, we need to write the code, see its result in action, and make modifications and adjustments accordingly. When I deal with the opaque predicate, once my assumption was too wide and the deobfuscated code is empty. Then I have to go back and examine every branch the tool patched out and see which one is wrong (and should not be wiped out). One thing I did is to write a simple test C program, produce both the original binary and an obfuscated binary, and then test my tool on it. This allows me to fix several bugs faster.</p>
<p>Automation is the result we want. However, we also need to make some compromise on this. Ideally, our program should take the binary as input and produce a deobfuscated one. However, I found there are too many corner cases so I decided that my tool will process one basic block a time. This allows me to verify if the result is correct. Later on, I enhanced it to process a function a time  &ndash; just iterate over the basic blocks in a function and process them one by one. Even this sometimes causes problem and I have to go back to process basic blocks one by one. The good part is my script is pretty robust that almost never needs any manual fixes.</p>
<h3 id="the-skeleton-of-a-binaryninja-plugin">The Skeleton of a BinaryNinja Plugin</h3>
<p>BinaryNinja allows a plugin to register a callback on an address.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python">PluginCommand<span style="color:#f92672">.</span>register_for_address(<span style="color:#e6db74">&#34;Deobfuscate&#34;</span>,
                                   <span style="color:#e6db74">&#34;Remove tcc&#34;</span>,
                                   bootstrap)
</code></pre></div><p><code>bootstrap</code> is the function that gets called every time we click the <code>Deobfuscate</code> context menu. It is just a wrapper around the <code>simplify_bbl_handler</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">simplify_bbl_handler</span>(bv, addr):
    bbl <span style="color:#f92672">=</span> bv<span style="color:#f92672">.</span>get_basic_blocks_at(addr)[<span style="color:#ae81ff">0</span>]
    instrs_to_include <span style="color:#f92672">=</span> simplify_bbl(bv, bbl)
    bv<span style="color:#f92672">.</span>begin_undo_actions()
    nop_excluded_instrs(bv, bbl, instrs_to_include)
    solve_load_bbl(bv, bbl)
    bv<span style="color:#f92672">.</span>commit_undo_actions()
</code></pre></div><p>We get the basic block at the current address by <code>bv.get_basic_blocks_at()</code>. Then we start the real deobfuscating. Note we also add undo actions which is quite handy during development &ndash; since we need to frequently change the code and see its result.</p>
<h3 id="solving-convoluted-constant-load">Solving Convoluted Constant Load</h3>
<p>The convoluted constant load is the first obfuscation technique we discussed. And it is used a lot across the binary. It is not hard to solve since its operations are simple. The problem is we need to locate it in the binary &ndash; where it starts and where it ends. This is trivial for a human reverser, but it is not easy for a program.</p>
<p>The implementation is in the function <code>solve_load_bbl()</code> in the <a href="solution/de-obfuscate/de-obfuscate.py">script</a>. The code is long so I cannot show it here. It does some pattern matching. It looks for consecutive arithmetic operations (<code>'add|sub|shl|shr|xor'</code>) on registers <code>['eax', 'ebx', 'ecx', 'edx']</code>. This might not be the <code>best</code> solution, but it works. We have to make some compromise since it is very hard to write the best code for a deobfuscator, which deals with messy things.</p>
<p>After discovering the pattern, it emulates the operations:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solve_load_ops</span>(bv, ops):
    val <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> opcode, operand <span style="color:#f92672">in</span> ops:
        <span style="color:#66d9ef">if</span> opcode <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;mov&#39;</span>:
            addr <span style="color:#f92672">=</span> int(operand, <span style="color:#ae81ff">16</span>)
            val_bytes <span style="color:#f92672">=</span> bv<span style="color:#f92672">.</span>read(addr, <span style="color:#ae81ff">4</span>)
            val <span style="color:#f92672">=</span> struct<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#39;&lt;I&#39;</span>, val_bytes)[<span style="color:#ae81ff">0</span>]
            <span style="color:#66d9ef">print</span>(hex(val))
        <span style="color:#66d9ef">elif</span> opcode <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;add&#39;</span>:
            val <span style="color:#f92672">=</span> (val <span style="color:#f92672">+</span> int(operand, <span style="color:#ae81ff">16</span>)) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffffffff</span>
        <span style="color:#66d9ef">elif</span> opcode <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;sub&#39;</span>:
            val <span style="color:#f92672">=</span> (val <span style="color:#f92672">-</span> int(operand, <span style="color:#ae81ff">16</span>)) <span style="color:#f92672">%</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">32</span>)
        <span style="color:#66d9ef">elif</span> opcode <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;xor&#39;</span>:
            val <span style="color:#f92672">=</span> val <span style="color:#f92672">^</span> int(operand, <span style="color:#ae81ff">16</span>)
        <span style="color:#66d9ef">elif</span> opcode <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;shl&#39;</span>:
            val <span style="color:#f92672">=</span> val <span style="color:#f92672">&lt;&lt;</span> int(operand, <span style="color:#ae81ff">16</span>)
            val <span style="color:#f92672">&amp;=</span> <span style="color:#ae81ff">0xffffffff</span>
        <span style="color:#66d9ef">elif</span> opcode <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;shr&#39;</span>:
            val <span style="color:#f92672">=</span> val <span style="color:#f92672">&gt;&gt;</span> int(operand, <span style="color:#ae81ff">16</span>)
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;unknown operation: </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> opcode)

    <span style="color:#66d9ef">return</span> val
</code></pre></div><p>After we calculate the final load value, we need to patch the code, which is super convenient in BinaryNinja.</p>
<h3 id="solving-obfuscated-calls">Solving Obfuscated Calls</h3>
<p>The obfuscated call needs to be restored. Note the obfuscated code has <code>jmp printf</code> in it, but we need to change it to <code>call printf</code>. And then add a <code>jmp</code> to the next function.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solve_push_jmp</span>(bv, func):

    <span style="color:#66d9ef">for</span> bbl <span style="color:#f92672">in</span> func<span style="color:#f92672">.</span>basic_blocks:
        <span style="color:#66d9ef">if</span> bbl<span style="color:#f92672">.</span>instruction_count <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>:
            <span style="color:#66d9ef">continue</span>
        
        disassembly_text <span style="color:#f92672">=</span> bbl<span style="color:#f92672">.</span>get_disassembly_text()
        <span style="color:#66d9ef">if</span> str(disassembly_text[<span style="color:#f92672">-</span><span style="color:#ae81ff">5</span>])<span style="color:#f92672">.</span>startswith(<span style="color:#e6db74">&#39;call    $+5&#39;</span>) <span style="color:#f92672">and</span> \
            str(disassembly_text[<span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>])<span style="color:#f92672">.</span>startswith(<span style="color:#e6db74">&#39;pop     eax&#39;</span>) <span style="color:#f92672">and</span> \
            str(disassembly_text[<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>])<span style="color:#f92672">.</span>startswith(<span style="color:#e6db74">&#39;add     eax, 0xa&#39;</span>) <span style="color:#f92672">and</span> \
            str(disassembly_text[<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>])<span style="color:#f92672">.</span>startswith(<span style="color:#e6db74">&#39;push    eax&#39;</span>) <span style="color:#f92672">and</span> \
            str(disassembly_text[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])<span style="color:#f92672">.</span>startswith(<span style="color:#e6db74">&#39;jmp&#39;</span>):

            patch_addr <span style="color:#f92672">=</span> disassembly_text[<span style="color:#f92672">-</span><span style="color:#ae81ff">5</span>]<span style="color:#f92672">.</span>address
            <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;push_jump at: 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> patch_addr)

            jmp_addr <span style="color:#f92672">=</span> disassembly_text[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>address
            callee_offset_bytes <span style="color:#f92672">=</span> bv<span style="color:#f92672">.</span>read(jmp_addr <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>)
            caller_offset <span style="color:#f92672">=</span> struct<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#39;&lt;i&#39;</span>, callee_offset_bytes)[<span style="color:#ae81ff">0</span>]
            callee_addr <span style="color:#f92672">=</span> jmp_addr <span style="color:#f92672">+</span> caller_offset <span style="color:#f92672">+</span> <span style="color:#ae81ff">5</span>

            dis <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;call 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> callee_addr
            inst_bytes <span style="color:#f92672">=</span> arch<span style="color:#f92672">.</span>assemble(dis, patch_addr)
            bv<span style="color:#f92672">.</span>write(patch_addr, inst_bytes)
            
            <span style="color:#75715e"># this sequence is 15 byte long</span>
            return_addr <span style="color:#f92672">=</span> patch_addr <span style="color:#f92672">+</span> <span style="color:#ae81ff">15</span>
            jmp_addr <span style="color:#f92672">=</span> patch_addr <span style="color:#f92672">+</span> len(inst_bytes)
            dis_jmp <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;jmp 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> return_addr

            inst_bytes <span style="color:#f92672">=</span> arch<span style="color:#f92672">.</span>assemble(dis_jmp, jmp_addr)
            bv<span style="color:#f92672">.</span>write(jmp_addr, inst_bytes)
</code></pre></div><p>We need to do some math to calculate the <code>callee_addr</code>, <code>return_addr</code>, and <code>jmp_addr</code>. Once we finish this the control flow is much better since we now know which functions get called.</p>
<h3 id="solving-opaque-predicate">Solving Opaque Predicate</h3>
<p>BinaryNinja already has a <a href="https://binary.ninja/2017/10/01/automated-opaque-predicate-removal.html">plugin</a> for patching opaque predicates. It relies on the lifted LLIL to see if the flags used in the conditional jump can be deduced from the preceding code, and patch it if so.</p>
<p>However, it does not suit my need because it does not take care of the convoluted constant load. Have a look at the following code:</p>
<pre><code>00401172  mov     eax, dword [data_41c000]
00401178  mov     ecx, dword [data_41c1ac]
0040117e  xor     ecx, 0x32744b9b
00401184  shl     ecx, 0x2
00401187  shl     ecx, 0x4
0040118a  sub     ecx, 0x63fa1799
00401190  shr     ecx, 0x2
00401193  xor     ecx, 0x6a18d496
00401199  sub     ecx, 0x756243af
0040119f  cmp     eax, ecx
004011a1  jge     0x401516
</code></pre><p>The <code>eax</code> is loaded directly from the memory, and <code>ecx</code> is also a constant. So the result of the comparison is deterministic. However, LLIL does not squash these arithmetic operations so it does not know this is an opaque predicate.</p>
<p>So I wrote my opaque predicate patcher. Here I read the source code of the obfuscator and found out that it only inject two types of opaque predicates: the first one is the <code>sub-and-jump</code> and the second is <code>xor-and-jump</code>. Both are quite easy to find. Then I just search for sub/xor instruction, whose two operands are the same, and it is followed by a conditional jump. If found, I patch it accordingly.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_opaque_predicate</span>(instr):

    tokens <span style="color:#f92672">=</span> instr<span style="color:#f92672">.</span>tokens
    <span style="color:#66d9ef">if</span> tokens[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>text <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;xor&#39;</span> <span style="color:#f92672">and</span> tokens[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">.</span>text <span style="color:#f92672">==</span> tokens[<span style="color:#ae81ff">4</span>]<span style="color:#f92672">.</span>text:
        <span style="color:#66d9ef">return</span> True
    <span style="color:#66d9ef">if</span> tokens[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>text <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;sub&#39;</span> <span style="color:#f92672">and</span> tokens[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">.</span>text <span style="color:#f92672">==</span> tokens[<span style="color:#ae81ff">4</span>]<span style="color:#f92672">.</span>text:
        <span style="color:#66d9ef">return</span> True   
    <span style="color:#66d9ef">return</span> False

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solve_opaque_predicate</span>(bv, func):

    <span style="color:#66d9ef">for</span> bbl <span style="color:#f92672">in</span> func<span style="color:#f92672">.</span>basic_blocks:

        <span style="color:#75715e"># jne to self</span>
        <span style="color:#66d9ef">if</span> bbl<span style="color:#f92672">.</span>instruction_count <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
            instr <span style="color:#f92672">=</span> bbl<span style="color:#f92672">.</span>get_disassembly_text()[<span style="color:#ae81ff">0</span>]
            <span style="color:#66d9ef">if</span> instr<span style="color:#f92672">.</span>tokens[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>text<span style="color:#f92672">.</span>startswith(<span style="color:#e6db74">&#39;jne&#39;</span>):
                bv<span style="color:#f92672">.</span>never_branch(instr<span style="color:#f92672">.</span>address)  
            <span style="color:#66d9ef">continue</span>

        instrs <span style="color:#f92672">=</span> bbl<span style="color:#f92672">.</span>get_disassembly_text()

        <span style="color:#66d9ef">try</span>:
            instr1, instr2 <span style="color:#f92672">=</span> instrs[<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span> :]
        <span style="color:#66d9ef">except</span>:
            <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;error at: 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> bbl<span style="color:#f92672">.</span>start)

        <span style="color:#66d9ef">if</span> is_opaque_predicate(instr1):
            <span style="color:#66d9ef">if</span> should_patch_to_always_branch(instr2):
                log_info(<span style="color:#e6db74">&#39;always branch at: 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> instr2<span style="color:#f92672">.</span>address)
                bv<span style="color:#f92672">.</span>always_branch(instr2<span style="color:#f92672">.</span>address)
            <span style="color:#66d9ef">elif</span> should_patch_to_never_branch(instr2):
                log_info(<span style="color:#e6db74">&#39;never branch at: 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> instr2<span style="color:#f92672">.</span>address)
                bv<span style="color:#f92672">.</span>never_branch(instr2<span style="color:#f92672">.</span>address)
</code></pre></div><p>A careful reader should already find that I made a mistake here. On the one hand, after I read the source code I find there are only two types of opaque predicates; on the other hand, I think the conditional shown above (<code>0040119f  cmp     eax, ecx; 004011a1  jge     0x401516</code>) is also opaque. The problem is this is a <code>cmp</code> followed by <code>jge</code>, which is not opaque at all!</p>
<p>The problem is the <code>00401172  mov     eax, dword [data_41c000]</code>. This is not a convoluted constant load; it is just a regular variable load! The value of <code>dword [data_41c000]</code> could change and this is a meaningful branch. After I realized this, I went back to change the code that solves the constant load: it has to have two operations at least.</p>
<h3 id="solving-junk-code">Solving Junk Code</h3>
<p>Junk code removal is the hardest part of this binary. It is not the most prominent technique used in it, but it does require a significant amount of work to solve. Junk code is easy to recognize for human reverser: it often contains a lot of meaningless/weird combinations of instructions. But this does not help a program to recognize them.</p>
<p>As I mentioned, simplification is probably the <code>right</code> way to do it. But it also requires a huge amount of work. I looked at the generated assembly and found one property of TCC can help us solve it more easily. This involves compiler theories but I will keep it as simple as possible.</p>
<p>TCC is <code>tiny</code> so it does not do a lot of optimization on the generated code. The <a href="https://lists.gnu.org/archive/html/tinycc-devel/2006-09/msg00028.html">email list</a> writes:</p>
<pre><code>TinyCC compiles every statement on its own. After every line of code,
values in registers are written back to the stack. And even if the next
line uses the variables that can still be found in registers, they are
read again from the stack.
</code></pre><p>This means, for TCC emitted code, if a value is calculated (and held in register) but not written back to the memory, then it is to be discarded. Though we do not necessarily see the register holding the value being over-written. This allows us to remove junk code on a basic block level rather than a function level, which is a lot easier to implement.</p>
<p>Note, however, the above statement is not true for other compilers, e.g., gcc. Gcc generates code that uses a register to hold the loop counter <code>i</code>. The value is never written back to the memory inside the loop. For code like that, it is harder to deduce if a value is used later or not.</p>
<p>The idea of the simplification is to pick all the useful instructions from a basic block. We start from instructions that write to the memory. And we do backward taint analysis on all of them to get a set of instructions that affect the final value written to the memory. We do this repeatedly until no new instructions are added. Then we get all the useful instructions. Finally, we remove all the useless instructions (junk code).</p>
<p>The code is in <code>simplify_bbl()</code>. It is quite long so I do not post it here. <a href="https://triton.quarkslab.com/">Triton</a> does the taint analysis. The recursion part is the most difficult to write.</p>
<p>This method will be voided if the obfuscator writes the junk value into the memory. However, it is also harder to implement since the obfuscator authors need to find a safe place to write to.</p>
<p>One question puzzles me for a long time until I read the source of the obfuscator. How does the junk code inserter make sure that it does not accidentally destroy some useful register value? For example, when it writes to <code>edx</code>, is it sure that <code>edx</code> does not hold any value that is used later? The answer is, TCC uses value stack (vstack) to keep track of values. And the obfuscator avoids writing to any registers in the vstack. The relevant code is:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">is_reg_in_vstack</span> (<span style="color:#66d9ef">int</span> r)
{
    SValue <span style="color:#f92672">*</span>p;

    <span style="color:#66d9ef">for</span>(p<span style="color:#f92672">=</span>vstack; p<span style="color:#f92672">&lt;=</span>vtop; p<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">if</span> (r<span style="color:#f92672">==</span>((p<span style="color:#f92672">-&gt;</span>r)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xFF</span>))
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
};
</code></pre></div><h3 id="nop-ing-out-useless-instructions">Nop-ing Out Useless Instructions</h3>
<p>We almost succeed! We have handled all the obfuscation techniques. The last step is to remove those junk code (as well as some residue of other obfuscations). We can simply <code>nop</code> them, but then it creates looooong nop slides which make the code hard to read. Moving the remaining code to make it compact is non-trivial. It affects relocation, inline data, etc. Later, I learned (thx Jordan!) that switching to LLIL automatically removes these nops, as shown below:</p>
<p><img src="../imgs/10.png" alt=""></p>
<p>However, when I approach the problem by myself, I found this is seldom discussed in deobfuscation literature so I came up with my own solution.</p>
<p>We still first patch the junk code with <code>nop</code>. Since a <code>jmp</code> is only 5 bytes long, if there is a nop-slide that is longer than 5 bytes, we create a <code>jmp</code> that directly jumps to the end of the nop slide. The logic is implemented in <code>nop_excluded_instrs()</code>. The result does not look perfect, but it is already much more readable:</p>
<p><img src="../imgs/8.png" alt=""></p>
<p>It first checks if argv[1] is 0. If so, it prints an error message. If not, it calls <code>strlen</code> on it and jumps to another function, which I named <code>check</code>.</p>
<h2 id="analyzing-the-algorithm">Analyzing the algorithm</h2>
<p>Finally, we get a clean binary that can be analyzed. The algorithm itself is not trivial and it requires some patience. It is probably a level 3 crackme if no obfuscation is applied. Though we will only cover the most important pieces of it.</p>
<p>Interestingly, the deobfuscated binary still has other obfuscations. The most prominent one is the buffer is processed in 16 functions. Each function takes care of 8 bytes of the buffer. the functions are functionally identical but it is not organized into a loop. The first function will call the second, the second will call the third, etc.</p>
<p>The key must be 128 bytes long. The buffer is first decrypted using a CBC mode XOR. The key is 16 DWORDs calculated dynamically. We do not care about how the key is calculated; we just need to dump it once the programs calculated it.</p>
<p>The decrypted buffer contains the serial number, user name, enabled feature sets, and expiration date. At the end of it, there is a checksum value. The checksum is calculated at sub_415353. One has to be familiar with the calculation of crc32 to understand this function. This is calculating a crc32 of the input buffer using magic value 0xedb88320 (see address 0x415747).</p>
<p>Finally, we arrived at the keygen script:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#f92672">import</span> struct 

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">crc32</span>(s, init_val <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, final_xor <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>):

    poly <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xedb88320</span>
    crc <span style="color:#f92672">=</span> init_val
    <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> s:
        <span style="color:#66d9ef">if</span> type(c) <span style="color:#f92672">==</span> str:
            asc <span style="color:#f92672">=</span> ord(c)
        <span style="color:#66d9ef">else</span>:
            asc <span style="color:#f92672">=</span> c

        asc <span style="color:#f92672">^=</span> <span style="color:#ae81ff">0xffffffff</span>
        crc <span style="color:#f92672">^=</span> asc

        <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">8</span>):
            eax <span style="color:#f92672">=</span> crc <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>
            var_c_1 <span style="color:#f92672">=</span> (<span style="color:#f92672">-</span>eax) <span style="color:#f92672">%</span> <span style="color:#ae81ff">0xffffffff</span>

            var_8 <span style="color:#f92672">=</span> crc <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>
            var_c_1 <span style="color:#f92672">&amp;=</span> poly

            crc <span style="color:#f92672">=</span> var_8 <span style="color:#f92672">^</span> var_c_1

        crc <span style="color:#f92672">^=</span> <span style="color:#ae81ff">0xffffffff</span>

    crc <span style="color:#f92672">^=</span> final_xor   
    <span style="color:#66d9ef">return</span> crc  

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">transform_back</span>(buffer):

    rngs_vals <span style="color:#f92672">=</span> [
        <span style="color:#ae81ff">0x10D88067</span>, 
        <span style="color:#ae81ff">0xBC16D3D5</span>, 
        <span style="color:#ae81ff">0xE7039A64</span>, 
        <span style="color:#ae81ff">0x39EC8A6D</span>, 
        <span style="color:#ae81ff">0xFF09B4BF</span>, 
        <span style="color:#ae81ff">0xF828DB76</span>, 
        <span style="color:#ae81ff">0x8BE40C8E</span>, 
        <span style="color:#ae81ff">0xF7AA583E</span>, 
        <span style="color:#ae81ff">0x60858E23</span>, 
        <span style="color:#ae81ff">0xE487F5A3</span>, 
        <span style="color:#ae81ff">0x39A57B89</span>, 
        <span style="color:#ae81ff">0xB006573E</span>, 
        <span style="color:#ae81ff">0x79609807</span>, 
        <span style="color:#ae81ff">0x620AD108</span>, 
        <span style="color:#ae81ff">0x5CD86398</span>, 
        <span style="color:#ae81ff">0x6CA94B51</span>
    ]
    var_0x8c <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

    ints <span style="color:#f92672">=</span> struct<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#39;&lt;&#39;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;I&#39;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">16</span>, buffer)
    restored_ints <span style="color:#f92672">=</span> []

    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">16</span>):
        restored_int <span style="color:#f92672">=</span> ints[i] <span style="color:#f92672">^</span> rngs_vals[i] <span style="color:#f92672">^</span> var_0x8c
        restored_ints<span style="color:#f92672">.</span>append(restored_int)
        var_0x8c <span style="color:#f92672">=</span> restored_int

    <span style="color:#66d9ef">return</span> restored_ints

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():

    name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;jeff&#39;</span>
    sn <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x12348765</span>
    feature <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x123</span>
    expire_year <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x2981</span>
    expire_month <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x34</span>
    expire_date <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x12</span>

    buffer <span style="color:#f92672">=</span> name <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">*</span> (<span style="color:#ae81ff">32</span> <span style="color:#f92672">-</span> len(name))
    buffer <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#39;&lt;I&#39;</span>, sn)
    buffer <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#39;&lt;I&#39;</span>, feature)
    buffer <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#39;&lt;H&#39;</span>, expire_year)
    buffer <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#39;&lt;B&#39;</span>, expire_month)
    buffer <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#39;&lt;B&#39;</span>, expire_date)

    buffer <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">16</span>

    crc <span style="color:#f92672">=</span> crc32(buffer)
    buffer <span style="color:#f92672">+=</span> struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#39;&lt;I&#39;</span>, crc)
    <span style="color:#66d9ef">print</span>(buffer<span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#39;hex&#39;</span>))

    restored_int <span style="color:#f92672">=</span> transform_back(buffer)

    key <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;</span>
    <span style="color:#66d9ef">for</span> val <span style="color:#f92672">in</span> restored_int:
        key <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%08x</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> val
    
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;key: &#39;</span>)
    <span style="color:#66d9ef">print</span>(key)


<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
    main()
</code></pre></div><!-- raw HTML omitted -->
<p>An example run looks like this:</p>
<pre><code>&gt;keygenme4.exe 76bee50dcaa836d82dabacbc144726d1eb4e926e13664918988245966f281da81d9914eef91ee06ed28fb2666289e5581be97d5f79e3ac57253bcfcf254ff9d4
Yonkie's keygenme#4 &lt;dennis@conus.info&gt;
licensed name=jeff
sn=12348765
featureset=0123
expiration=12342981
</code></pre>]]></content>
        </item>
        
        <item>
            <title>Examining the difference between C program and Assembly -- An Example of &lt;&lt; and shl</title>
            <link>/posts/reversing/shl_undefined_behavior/writeup/</link>
            <pubDate>Sat, 20 Jun 2020 00:00:00 +0000</pubDate>
            
            <guid>/posts/reversing/shl_undefined_behavior/writeup/</guid>
            <description>Encountering a Weird Issue Recently, I needed to write one function that returns a bitmask according to the number of bits. Basically, if the input is 8, it should return 0xff. The input n is in the range of 0-64 (both side include).
The first idea is to use left shift and then minus 1:
uint64_t getBitMask(size_t n) { uint64_t ret = (1UL &amp;lt;&amp;lt; n) - 1; return ret; } This works well when n is in the range of 0-63.</description>
            <content type="html"><![CDATA[<h2 id="encountering-a-weird-issue">Encountering a Weird Issue</h2>
<p>Recently, I needed to write one function that returns a bitmask according to the number of bits. Basically, if the input is 8, it should return 0xff. The input <code>n</code> is in the range of 0-64 (both side include).</p>
<p>The first idea is to use left shift and then minus 1:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">uint64_t <span style="color:#a6e22e">getBitMask</span>(size_t n)
{
    uint64_t ret <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1UL</span> <span style="color:#f92672">&lt;&lt;</span> n) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">return</span> ret;
}
</code></pre></div><p>This works well when n is in the range of 0-63. However, when n is 64, the code returns 0 instead of 0xffffffffffffffff.</p>
<p>I isolated the problem and created the following minimal PoC:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;inttypes.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">64</span>;
    uint64_t ret <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1UL</span> <span style="color:#f92672">&lt;&lt;</span> n) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    printf(<span style="color:#e6db74">&#34;0x%lx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ret);
}
</code></pre></div><p>And the command to compile and run it:</p>
<pre><code> $ gcc -o test test.c
 $ ./test
0x0
</code></pre><p>This result is counter-intuitive since when n is 64, the only bit in 1 should be shifted out and it becomes <code>0 - 1</code>, which should give me 0xffffffffffffffff.</p>
<p>I have no idea why it behaves like this so I decided to load the compiled binary into BinaryNinja to see what is happening.</p>
<h2 id="assembly-never-lies">Assembly Never Lies</h2>
<p><img src="../imgs/1.png" alt=""></p>
<p>It looks correct to me. Completely confused, I launched gdb and see what is happening. It quickly turns out that after the <code>shl rdx, cl</code> at 0x663, rdx remains 0x1 rather than becoming 0. And 1 - 1 is 0 &ndash; that is why 0x0 is printed.</p>
<p>Some vague impression of the shl instruction struck me. <code>cl</code> is 64 now, which is also the size of the register being shifted. Does it affect the execution? I navigated to the Intel reference manual and start reading the page that documents the shl instruction. I found this:</p>
<pre><code>The count operand can be an immediate value or the CL register. The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W is used). The count range is limited to 0 to 31 (or 63 if 64-bit mode and REX.W is used).
</code></pre><p>We are in 64-bit mode here. The documentation states that the bits beyond the lowest 6 are discarded. Now we have 64 (0b1000000) in cl, whose lowest 6 bits are zeros. No wonder rdx remains 1 after the shl &ndash; we are effectively shifting 0 bit.</p>
<p>Ok, things are sorted out now. But I decided to test how gcc handles this when optimizations are on. Because when we turn on optimization (e.g., -O2), it is very likely the value of <code>ret</code> is calculated by the compiler rather than in runtime. Does gcc also enforce the width limit on the shift count?</p>
<pre><code> $ gcc -O2 -o test_O2 test.c
 $ ./test_O2 
0xffffffffffffffff
</code></pre><p>Wow, the output is different from the previous one! And the disassembly looks like this:</p>
<p><img src="../imgs/2.png" alt=""></p>
<p>The value 0xffffffffffffffff is directly printed. It same gcc -O2 behaves in the same way as I expected &ndash; it ignores the limit on the shift count.</p>
<p>Well, we now get one source code that gives different result when compiled with <code>-O0</code> and <code>-O2</code>. Is this a gcc bug?</p>
<p>Nope, it is not. C standard actually defines the behavior as undefined:</p>
<pre><code>-- An expression is shifted by a negative number or by an amount greater than or equal to the width of the promoted expression (6.5.7).
</code></pre><p>Since this behavior is undefined, the difference between the <code>-O0</code> and <code>-O2</code> is not a bug.</p>
<p>Back to the function I need to write, although there might be a way to implement the functionality without a branch, it probably exploits certain implementation of a particular compiler. Which is unreliable and bad for cross-platform and cross-compiler compatibility. I decided to put a <code>if</code> for the case <code>n == 64</code>.</p>
<h2 id="epilog">Epilog</h2>
<p>Differences between the C source code and the compiled x86 binary is an well-known issue. This paper comes to my mind first: <a href="https://research.cs.wisc.edu/wpis/papers/wysinwyx.final.pdf">WYSINWYX:What You See Is Not What You eXecute</a>.</p>
<p>C is quite low level so it has a close relation with the underlying hardware. C standard defines certain behavior as undefined to save the effort of C compiler authors. If the <code>&lt;&lt;</code> operator is defined when the shift count is larger than or equal to the register width, there will be more branches in the compiler code to take care of many edge cases.</p>
<p>Reading the assembly is probably the best method to resolve similar issues. In fact, during the development I once missed the <code>UL</code> after the constant <code>1</code>. And the code stops working after the n is larger than 32.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">48</span>;
    uint64_t ret <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> n) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    printf(<span style="color:#e6db74">&#34;0x%lx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ret);
}
</code></pre></div><p>When the above code is compiled with <code>-O0</code>, it prints <code>0xffff</code>. Why? Because 1 is considered a 32-bit integer and gcc decides to use <code>edx</code> (instead of <code>rdx</code>) to hold it.</p>
<p><img src="../imgs/3.png" alt=""></p>
<p>Since 48 = 0b110000, and only the lowest 5 bits are involved in the calculation, we are effectively left shifting 16 bits. That is why we get 0xffff as the output.</p>
<p>Last but not least, what would we get if we compile the above code with <code>-O2</code>? The result is surprising to me at first sight, followed by an aha moment.</p>
]]></content>
        </item>
        
        <item>
            <title>Solving an ARM challenge with z3</title>
            <link>/posts/reversing/armageddon/solve/</link>
            <pubDate>Thu, 18 Jun 2020 00:00:00 +0000</pubDate>
            
            <guid>/posts/reversing/armageddon/solve/</guid>
            <description>First Impression The last week&amp;rsquo;s challenge is hosted at https://crackmes.one/crackme/5edb0b8533c5d449d91ae73b. It is authored by Towel and it is a real challenge in UMDCTF 2019.
Loading it into BinaryNinja reveals that it is an ARM binary. Not very surprised as its name is armageddon. ARM is no longer special for me as I gradually become familiar with the ISA. After all, it is simpler than the x86 and those frequently used instructions are easy to understand and remember.</description>
            <content type="html"><![CDATA[<h2 id="first-impression">First Impression</h2>
<p>The last week&rsquo;s challenge is hosted at <a href="https://crackmes.one/crackme/5edb0b8533c5d449d91ae73b">https://crackmes.one/crackme/5edb0b8533c5d449d91ae73b</a>. It is authored by Towel and it is a real challenge in UMDCTF 2019.</p>
<p>Loading it into BinaryNinja reveals that it is an ARM binary. Not very surprised as its name is <code>armageddon</code>. ARM is no longer special for me as I gradually become familiar with the ISA. After all, it is simpler than the x86 and those frequently used instructions are easy to understand and remember.</p>
<p>BinaryNinja has no problem recognizing the <code>__libc_start_main</code> and I can get to <code>main</code> easily. The first thing I find is that <code>main</code> is a <strong>long</strong> function.</p>
<p><img src="../imgs/2.png" alt=""></p>
<p>Well, a long function is not necessarily hard to analyze. It probably leverages certain obfuscation and/or its code is pretty repetitive. I started browsing the code from the beginning.</p>
<p><img src="../imgs/1.png" alt=""></p>
<p>It first prints a welcoming message and then asks the user to type the input. After that, it calls <code>scanf</code> with <code>&quot;%41s&quot;</code> which reads at most 41 chars from the terminal. Not bad, we now know it accepts a string as the input and we know the maximum length of it.</p>
<p>We also notice that the basic blocks are split into quite short ones. This is probably an obfuscation technique. Nevetheless BinaryNinja kind of automatically accounts for it so we are not bothered by it. If a disassembler does not correctly inline the blocks after the jump (<code>b</code>), it could be harder to analyze.</p>
<p>After reading the input, the code becomes repetitive: each time, a function is called with the user input as its only parameter. The pattern is repeated until near the bottom of the function, where a loop is found. The loop could be decrypting the flag based on the correct user input. And the checks on the input is obviously inside these called functions.</p>
<p>I followed the first check function and it looks like this:</p>
<p><img src="../imgs/3.png" alt=""></p>
<p>Near the bottom of the function we see the comparison and if the comparison is not equal, an error message is printed. After analyzing the algorithm, I find the constraint is:</p>
<pre><code>passwd[1] * passwd[0x27] * passwd[0x15] + passwd[0x11] + passwd[0x13] * passwd[0x1e] == 0xdb11e
</code></pre><p>I browsed several other check functions and they all look similar. Now it becomes obvious: There are a series of constraints and the correct input must satisfy all of them.</p>
<h2 id="round-one-failure-of-angr">Round One: Failure of angr</h2>
<p>This challenge is very suitable for tools like <code>angr</code> or <code>z3</code>. In fact angr also uses z3 as its constraint solving backend. However, angr can automatically extract constraints from the binary, which could save a lot of time for reversers. So I decided to first give angr a try.</p>
<p>The code is not hard to write &ndash; especially they all look similar for different binaries.</p>
<p>Code for <a href="../angr-solve.py">angr-solve.py</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#f92672">import</span> angr
<span style="color:#f92672">import</span> claripy

proj <span style="color:#f92672">=</span> angr<span style="color:#f92672">.</span>Project(<span style="color:#e6db74">&#39;./armageddon&#39;</span>)
<span style="color:#66d9ef">print</span>(hex(proj<span style="color:#f92672">.</span>entry))
start_address <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x14a88</span>
state <span style="color:#f92672">=</span> proj<span style="color:#f92672">.</span>factory<span style="color:#f92672">.</span>entry_state(addr <span style="color:#f92672">=</span> start_address)

input_addr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xaa000000</span>
r11 <span style="color:#f92672">=</span> input_addr <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x34</span>
state<span style="color:#f92672">.</span>regs<span style="color:#f92672">.</span>r11 <span style="color:#f92672">=</span> r11

n <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>
flag <span style="color:#f92672">=</span> state<span style="color:#f92672">.</span>solver<span style="color:#f92672">.</span>BVS(<span style="color:#e6db74">&#39;flag&#39;</span>, n <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>)
state<span style="color:#f92672">.</span>memory<span style="color:#f92672">.</span>store(input_addr, flag)

simgr <span style="color:#f92672">=</span> proj<span style="color:#f92672">.</span>factory<span style="color:#f92672">.</span>simgr(state)
good <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x1504c</span>
simgr<span style="color:#f92672">.</span>explore(find <span style="color:#f92672">=</span> good,
        avoid <span style="color:#f92672">=</span> [
            <span style="color:#ae81ff">0x10674</span>,
            <span style="color:#ae81ff">0x107c8</span>,
            <span style="color:#ae81ff">0x109ac</span>,
            <span style="color:#ae81ff">0x10b6c</span>,
            <span style="color:#ae81ff">0x10cf0</span>,
            <span style="color:#ae81ff">0x10ea4</span>,
            <span style="color:#ae81ff">0x11010</span>,
            <span style="color:#ae81ff">0x11190</span>,
            <span style="color:#ae81ff">0x11308</span>,
            <span style="color:#ae81ff">0x114a4</span>,
            <span style="color:#ae81ff">0x116a8</span>,
            <span style="color:#ae81ff">0x1185c</span>,
            <span style="color:#ae81ff">0x119c8</span>,
            <span style="color:#ae81ff">0x11b84</span>,
            <span style="color:#ae81ff">0x11d38</span>,
            <span style="color:#ae81ff">0x11f10</span>,
            <span style="color:#ae81ff">0x120c4</span>,
            <span style="color:#ae81ff">0x122e4</span>,
            <span style="color:#ae81ff">0x124c8</span>,
            <span style="color:#ae81ff">0x1264c</span>,
            <span style="color:#ae81ff">0x12800</span>,
            <span style="color:#ae81ff">0x12948</span>,
            <span style="color:#ae81ff">0x12b1c</span>,
            <span style="color:#ae81ff">0x12d30</span>,
            <span style="color:#ae81ff">0x12e9c</span>,
            <span style="color:#ae81ff">0x13070</span>,
            <span style="color:#ae81ff">0x13248</span>,
            <span style="color:#ae81ff">0x133e0</span>,
            <span style="color:#ae81ff">0x135f0</span>,
            <span style="color:#ae81ff">0x137d4</span>,
            <span style="color:#ae81ff">0x13970</span>,
            <span style="color:#ae81ff">0x13b50</span>,
            <span style="color:#ae81ff">0x13cbc</span>,
            <span style="color:#ae81ff">0x13e6c</span>,
            <span style="color:#ae81ff">0x14014</span>,
            <span style="color:#ae81ff">0x141c8</span>,
            <span style="color:#ae81ff">0x1434c</span>,
            <span style="color:#ae81ff">0x144c4</span>,
            <span style="color:#ae81ff">0x14648</span>,
            <span style="color:#ae81ff">0x1485c</span>,
            <span style="color:#ae81ff">0x149a0</span>
        ]
        ) 

<span style="color:#66d9ef">if</span> simgr<span style="color:#f92672">.</span>found:
    solution_state <span style="color:#f92672">=</span> simgr<span style="color:#f92672">.</span>found[<span style="color:#ae81ff">0</span>]
    input1 <span style="color:#f92672">=</span> solution_state<span style="color:#f92672">.</span>solver<span style="color:#f92672">.</span>eval(flag, cast_to <span style="color:#f92672">=</span> bytes)
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;flag: &#39;</span>, input1)
<span style="color:#66d9ef">else</span>:
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;Cound not find flag&#39;</span>)

</code></pre></div><p>We tell angr where is the input, and specify a good address to reach, as well as an (optional) list of addresses to avoid. Those addresses to be avoided are those printing error messages.</p>
<p>This, in theory, should work. However, after running for several minutes angr tells me there is no solution. This is a little bit surprising as I assume as long as there is a solution, angr either returns it or keeps running. There could be multiple reasons for it, e.g., a bug in angr, or the constraints are not properly lifted, etc. We could output the constraints that angr is solving and troubleshot what went wrong. But please allow me to save it as future work.</p>
<h2 id="round-two-conquering-it-with-z3">Round Two: Conquering it with z3</h2>
<p>The next option is to convert the constraints into Python syntax and solve it with z3. The transcribing is arduous work and prone to error. It is better done in an automated or semi-automated way.</p>
<p>I opened the challenge binary in Ghidra and found that the decompilation is generally good:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">FUN_000104fc</span>(<span style="color:#66d9ef">int</span> param_1)

{
  <span style="color:#66d9ef">if</span> ((uint)<span style="color:#f92672">*</span>(byte <span style="color:#f92672">*</span>)(param_1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span>
      (uint)<span style="color:#f92672">*</span>(byte <span style="color:#f92672">*</span>)(param_1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x27</span>) <span style="color:#f92672">*</span> (uint)<span style="color:#f92672">*</span>(byte <span style="color:#f92672">*</span>)(param_1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x15</span>) <span style="color:#f92672">+</span>
      (uint)<span style="color:#f92672">*</span>(byte <span style="color:#f92672">*</span>)(param_1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x11</span>) <span style="color:#f92672">+</span>
      (uint)<span style="color:#f92672">*</span>(byte <span style="color:#f92672">*</span>)(param_1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x13</span>) <span style="color:#f92672">*</span> (uint)<span style="color:#f92672">*</span>(byte <span style="color:#f92672">*</span>)(param_1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x1e</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0xdb11e</span>) {
    puts(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">[!] Code did not validate! :(</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
                    <span style="color:#75715e">/* WARNING: Subroutine does not return */</span>
    exit(<span style="color:#ae81ff">0</span>);
  }
  <span style="color:#66d9ef">return</span> param_1;
}
</code></pre></div><p>Then I copy-and-pasted all the constraints into a temp script and converted it into Python syntax. Note this work is still quite repetitive, so I decided to convert the code with a regular expression.</p>
<p>I did it in VS Code. I searched for</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python">\(uint\)\<span style="color:#f92672">*</span>\(byte \<span style="color:#f92672">*</span>\)\(param_1 \<span style="color:#f92672">+</span> ((<span style="color:#ae81ff">0</span>x)<span style="color:#960050;background-color:#1e0010">?</span>[<span style="color:#ae81ff">0</span><span style="color:#f92672">-</span><span style="color:#ae81ff">9</span>a<span style="color:#f92672">-</span>f]<span style="color:#f92672">+</span>)\)
</code></pre></div><p>and replaced them with</p>
<pre><code>passwd[$1]
</code></pre><p>Basically, this will convert <code>(uint)*(byte *)(param_1 + 1)</code> to <code>passwd[1]</code>. There are still manual works needed, like removing the <code>if</code>, etc. But those are not hard to do.</p>
<p>Eventually, the solving script looks like this <a href="../z3_solve.py">(z3_solve.py)</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#f92672">from</span> z3 <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>

n <span style="color:#f92672">=</span> <span style="color:#ae81ff">41</span>
passwd <span style="color:#f92672">=</span> [BitVec(<span style="color:#e6db74">&#39;s_</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> i, <span style="color:#ae81ff">32</span>)  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n)]

s <span style="color:#f92672">=</span> Solver()
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
    s<span style="color:#f92672">.</span>add(passwd[i] <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0x21</span>)
    s<span style="color:#f92672">.</span>add(passwd[i] <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">127</span>)

s<span style="color:#f92672">.</span>add(passwd[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x27</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x15</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x11</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x13</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x1e</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xdb11e</span>)
s<span style="color:#f92672">.</span>add(passwd[<span style="color:#ae81ff">0x25</span>] <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x13</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0xc</span>] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0xc0c</span>)
s<span style="color:#f92672">.</span>add(((passwd[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x1f</span>]) <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x21</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0xd</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x14</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x11</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xebd1d</span>)
s<span style="color:#f92672">.</span>add((passwd[<span style="color:#ae81ff">7</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x24</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0xf</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x1d</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x22</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x18e5</span>)
s<span style="color:#f92672">.</span>add((passwd[<span style="color:#ae81ff">0x15</span>] <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x1b</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0xf</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x11</span>] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0x2e3b</span>)
s<span style="color:#f92672">.</span>add(((passwd[<span style="color:#ae81ff">0xf</span>] <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x25</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">8</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">5</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">6</span>] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0x19a5</span>)
s<span style="color:#f92672">.</span>add(((passwd[<span style="color:#ae81ff">0x23</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x1d</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x14</span>]) <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x1a</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xc4</span>)
s<span style="color:#f92672">.</span>add(passwd[<span style="color:#ae81ff">7</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x20</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x1f</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0xb</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x45ca</span>)
s<span style="color:#f92672">.</span>add(passwd[<span style="color:#ae81ff">0x1d</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x18</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x24</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x25</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xac3fb</span>)
s<span style="color:#f92672">.</span>add(((passwd[<span style="color:#ae81ff">8</span>] <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x10</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0xc</span>]) <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x28</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0xf</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xd0</span>)
s<span style="color:#f92672">.</span>add((passwd[<span style="color:#ae81ff">0x23</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x11</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x0</span>] <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0xb</span>]) <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0xc</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">7</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x26</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x172e48</span>)
s<span style="color:#f92672">.</span>add(((passwd[<span style="color:#ae81ff">0x1a</span>] <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0xd</span>]) <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">8</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">5</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x10b8</span>)
s<span style="color:#f92672">.</span>add(passwd[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x11</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x24</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x14</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x160</span>)
s<span style="color:#f92672">.</span>add((passwd[<span style="color:#ae81ff">0x1a</span>] <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x15</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x12</span>]) <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x1b</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x19</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x8a2</span>)
s<span style="color:#f92672">.</span>add((passwd[<span style="color:#ae81ff">0x22</span>] <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0xe</span>]) <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">5</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x21</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x23</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x1bd8</span>)
s<span style="color:#f92672">.</span>add(passwd[<span style="color:#ae81ff">5</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">8</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x26</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x19</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x15</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x23</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x2ca6988</span>)
s<span style="color:#f92672">.</span>add((passwd[<span style="color:#ae81ff">8</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">8</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x15</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0xc</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x24</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x2430</span>)
s<span style="color:#f92672">.</span>add((((passwd[<span style="color:#ae81ff">0x23</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">2</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">7</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">9</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x12</span>]) <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x27</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x2de</span>)
s<span style="color:#f92672">.</span>add(((passwd[<span style="color:#ae81ff">5</span>] <span style="color:#f92672">*</span> (passwd[<span style="color:#ae81ff">0x11</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">6</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x14</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x22</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x17</span>] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0x11d5</span>)
s<span style="color:#f92672">.</span>add((passwd[<span style="color:#ae81ff">0x22</span>] <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0xb</span>]) <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0xb</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0xd</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x2aba</span>)
s<span style="color:#f92672">.</span>add((passwd[<span style="color:#ae81ff">0x22</span>] <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0xb</span>]) <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0xb</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0xd</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x2aba</span>)
s<span style="color:#f92672">.</span>add(passwd[<span style="color:#ae81ff">0x1b</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x12</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0xf</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x20</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">9</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x2668</span>)
s<span style="color:#f92672">.</span>add(passwd[<span style="color:#ae81ff">0x15</span>] <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0xe</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x1d</span>] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0x1400</span>)
s<span style="color:#f92672">.</span>add((((passwd[<span style="color:#ae81ff">9</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">9</span>] <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">10</span>]) <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0xd</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x24</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x14</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x19ac</span>)
s<span style="color:#f92672">.</span>add(((passwd[<span style="color:#ae81ff">0xc</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x22</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x14</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x17</span>]) <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x16</span>] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0xafa0c</span>)
s<span style="color:#f92672">.</span>add(((passwd[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">5</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">10</span>]) <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x1b</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xb4</span>)
s<span style="color:#f92672">.</span>add(((passwd[<span style="color:#ae81ff">0xf</span>] <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x1c</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x25</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x18</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x12</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x0</span>] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0xd06e8</span>)
s<span style="color:#f92672">.</span>add(((passwd[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x23</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x19</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x15</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x18</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x14</span>] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0x1f8</span>)
s<span style="color:#f92672">.</span>add((((passwd[<span style="color:#ae81ff">0x19</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">10</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0xf</span>]) <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x1c</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x21</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x3e</span>)
s<span style="color:#f92672">.</span>add((((passwd[<span style="color:#ae81ff">6</span>] <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x19</span>]) <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">2</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x19</span>]) <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x12</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x1c</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x1eb9</span>)
s<span style="color:#f92672">.</span>add(passwd[<span style="color:#ae81ff">0xb</span>] <span style="color:#f92672">*</span> (passwd[<span style="color:#ae81ff">5</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x22</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x16</span>]) <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0xc</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x22</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x121b93</span>)
s<span style="color:#f92672">.</span>add((((passwd[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0xe</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x26</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0xd</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0x80</span>)
s<span style="color:#f92672">.</span>add((((passwd[<span style="color:#ae81ff">0x1e</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x15</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x11</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x17</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">5</span>]) <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x21</span>] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0x1afd</span>)
s<span style="color:#f92672">.</span>add((passwd[<span style="color:#ae81ff">7</span>] <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0xe</span>]) <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x11</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x21</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xdf</span>)
s<span style="color:#f92672">.</span>add((passwd[<span style="color:#ae81ff">8</span>] <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">3</span>]) <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">10</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">10</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x626e2</span>)
s<span style="color:#f92672">.</span>add(((passwd[<span style="color:#ae81ff">0x25</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">7</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x13</span>]) <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0xc</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0xb</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x12f</span>)
s<span style="color:#f92672">.</span>add(passwd[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">8</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x14</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x20</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0xf</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x167a</span>)
s<span style="color:#f92672">.</span>add((passwd[<span style="color:#ae81ff">0x11</span>] <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">4</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x1d</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x12</span>] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0x11ca</span>)
s<span style="color:#f92672">.</span>add((passwd[<span style="color:#ae81ff">0xd</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x16</span>] <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">10</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x23</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x32e9</span>)
s<span style="color:#f92672">.</span>add(passwd[<span style="color:#ae81ff">0xd</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0xb</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x1d</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x13</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xec9</span>)
s<span style="color:#f92672">.</span>add((((passwd[<span style="color:#ae81ff">0x19</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x26</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0xf</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0xb</span>]) <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x20</span>]) <span style="color:#f92672">-</span> passwd[<span style="color:#ae81ff">0x15</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">0x22</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x2a</span>)
s<span style="color:#f92672">.</span>add(passwd[<span style="color:#ae81ff">6</span>] <span style="color:#f92672">*</span> passwd[<span style="color:#ae81ff">9</span>] <span style="color:#f92672">+</span> passwd[<span style="color:#ae81ff">0x23</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xedd</span>)

<span style="color:#66d9ef">if</span> s<span style="color:#f92672">.</span>check() <span style="color:#f92672">==</span> sat:
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;solved!&#39;</span>)
    m <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span>model()
    flag <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;</span>
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
        c <span style="color:#f92672">=</span> m[passwd[i]]<span style="color:#f92672">.</span>as_long()
        flag <span style="color:#f92672">+=</span> chr(c)
    <span style="color:#66d9ef">print</span>(flag)
<span style="color:#66d9ef">else</span>:
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;failed&#39;</span>)
</code></pre></div><p>One thing to mention here is although the individual chars of passwd are only 8 bits wide, we declare them to be 32-bit wide. Otherwise, it could cause a problem to the <code>==</code> at the end of the line. Obviously, we have to add the constraint <code>passwd[i] &gt;= 0x21</code> and <code>passwd[i] &lt;= 127</code>, to actually enforce they are printable ASCII chars.</p>
<p>Running this immediately returns the flag:</p>
<pre><code>UMDCTF-{ARM_1s_s0_SATisfying_7y8fdlsjebn}
</code></pre><h2 id="epilog">Epilog</h2>
<p>Despite z3 returns a result and it looks quite convincing, there are still some code below the last constraint. Typically, in CTF, this means the correct input that passes the constraints is NOT the actual flag; rather the input is used to decrypt the flag to be submitted. However, the above code is already in a good flag format. This confuses me so I decide to run the binary to see what happens. There is an excellent tool for this situation: the process level emulator &ndash; <a href="https://www.qiling.io/"><code>Qiling</code></a>.</p>
<p>Qiling is an emulator based on Unicorn. It is simpler than Qemu since it only emulates the process that we are interested in. So there is no need to set up a bulky OS to run it. The code is extremely simple <a href="../qiling_emulate.py">(qiling_emulate.py)</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#f92672">from</span> qiling <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>

<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;__main__&#34;</span>:
    ql <span style="color:#f92672">=</span> Qiling([<span style="color:#e6db74">&#34;./armageddon&#34;</span>], <span style="color:#e6db74">&#34;QILING_INSTALL_PATH/examples/rootfs/arm_linux&#34;</span>)
    ql<span style="color:#f92672">.</span>run()
</code></pre></div><p>Since major system calls are implemented by Qiling, the program executes properly. Below is an excerpt of the output:</p>
<pre><code>write(1,27008,16) = 0
[+] write() CONTENT: bytearray(b'[+] Enter Code: ')
[+] Enter Code: UMDCTF-{ARM_1s_s0_SATisfying_7y8fdlsjebn}
read(0, 0x29010, 0x2000) = 42
write(1,27008,1) = 0
[+] write() CONTENT: bytearray(b'\n')

write(1,27008,33) = 0
[+] write() CONTENT: bytearray(b'[+] Code validated successfully!\n')
[+] Code validated successfully!
write(1,27008,1) = 0
[+] write() CONTENT: bytearray(b'\n')

[!] 0xf7ca9be8: syscall number = 0x8c(140) not implemented
exit_group(0)
</code></pre><p>So after we supply the correct code, it simply prints <code>Code validated successfully!\n</code>.</p>
<p>LoL! I forget that it does not tell us the code is correct yet. Well, not bad, since playing with Qiling is quite painless.</p>
]]></content>
        </item>
        
        <item>
            <title>Debugging and Solving an Android Challenge</title>
            <link>/posts/reversing/quarkslab_android_crackme/main/</link>
            <pubDate>Sat, 30 May 2020 00:00:00 +0000</pubDate>
            
            <guid>/posts/reversing/quarkslab_android_crackme/main/</guid>
            <description>Our first challenge is an Android challenge that features native library reverse engineering and debugging. Since the algorithm itself is not very complex, in this writeup I will cover the major steps to set up an Android debugging environment. I will also share some of my thoughts as we progress.
First Impression The challenge is created by Quarkslab. The crackme-telegram.apk is ~25MB in size which is larger than a typical crackme.</description>
            <content type="html"><![CDATA[<p>Our first challenge is an Android challenge that features native library reverse engineering and debugging. Since the algorithm itself is not very complex, in this writeup I will cover the major steps to set up an Android debugging environment. I will also share some of my thoughts as we progress.</p>
<h2 id="first-impression">First Impression</h2>
<p>The <a href="https://blog.quarkslab.com/android-challenge.html">challenge</a> is created by Quarkslab. The <strong>crackme-telegram.apk</strong> is ~25MB in size which is larger than a typical crackme. One of the challenges in real-world reverse engineering is the huge size of the binary. There are too many possible places to hide the crucial code so even finding it is non-trivial in the first place.</p>
<p>Unzipping the apk gives us a folder that has <strong>classes.dex</strong> and sub-folder <strong>lib</strong> in it. The code for an Android app can be either in the .dex file or the native libraries. the .dex file is typically produced from Java whereas the native libraries are mostly complied from C/C++. And they require different reverse engineering skills. Nevertheless, here I want to share a heuristic: <strong>if an android crackme has native libraries, almost certainly the important code sits in these  libs.</strong> Well, this is not 100% reliable and the situation could change since I publish this, but it works very well for now.</p>
<h2 id="creating-an-avd-and-running-the-app">Creating an AVD and Running the App</h2>
<p>I do not have an Android phone or tablet so I need to run it in an emulator. There are many available Android emulators. In this writeup, I will use the official <a href="https://developer.android.com/studio/">Android Studio</a>. This crackme comes with both Arm and x86 versions of the native library, so we can run it in an x86 AVD (Android Virtual Device). Otherwise, I would have to use the Arm CPU AVD, which also works but runs slow on my Intel CPU.</p>
<p>Creating an AVD should be quite straightforward following this <a href="https://developer.android.com/studio/run/managing-avds">document</a>. I got one with API 28 and x86 CPU. Once we launch the app, it prompts us to register with a phone number:</p>
<p><img src="../imgs/wrong.png" alt=""></p>
<p>If we randomly input a phone number, we will be greeted by an error message. So this is already the main crackme. We need to find a special phone number (along with the country code) that is accepted by the app.</p>
<h2 id="finding-the-code">Finding the Code</h2>
<p>As always, we need to first locate the code which does the verification. One clue is the error message itself: <strong>Wrong number! Try again</strong>. This string can be found in the libtmessages.29.so. However, there are no Xrefs to it. Now there are several possibilities: 1. the string will be used but the code is obfuscated so my disassembler does not find a reference to it; 2. the string is not used and the code is somewhere else. I continued to search in class.dex, libtmessages.28.so, and also used <a href="https://ibotpeaches.github.io/Apktool/">Apktool</a> to unpack the resources.arsc. Nothing else can be found.</p>
<p>I do not want to create the illusion that I <strong>systematically</strong> find the verification function. Actually, I took some detous here. I reversed the class.dex and libtmessages.28.so for a while without success before I tried the libtmessages.29.so. This is indeed quite common in reverse engineering. Going back to the libtmessages.29.so, I had a look at the JNI_OnLoad() which has some related stuff but does not have the verification function. I checked the functions before and after the JNI_OnLoad() to see if there are any interesting functions. The logic is compilers tend to arrange the functions close to each other in the source code also adjacent to the generated binary. So there is a chance the important function is near the JNI_OnLoad().</p>
<p>I spotted the <strong>data_6871</strong> that sits right after the function. It starts with 0x5b81, which looks like code for me.</p>
<p><img src="../imgs/data.png" alt=""></p>
<p>Then I defined a function here and it is real code. It seems innocent at first look, but I quickly noticed that it is preparing a constant string on the stack:</p>
<p><img src="../imgs/analyze_me.png" alt=""></p>
<pre><code>Are you trying to analyze me?
</code></pre><p>It looks like a message related to anti-debugging &ndash; we might see this while debugging the app. Remember we are not yet sure whether this is related to the verification, so it is worthy to debug it now and see if this function is called.</p>
<h2 id="setting-up-debugging">Setting up Debugging</h2>
<p>Simply put, debugging an android app is a remote debugging scene. We run the <strong>gdbserver</strong> on the phone (either an emulator or a real one) and attach it to the target process. And then we launch <strong>gdb</strong> on our computer and connect to the remote target. After that, there is no difference between debugging locally and remotely.</p>
<p>An android app may run inside a Dalvik VM. However, the VM is just a regular process and can be debugged like any other processes. Furthermore, the native libraries are directed loaded into the process memory space so we can also debug that.</p>
<p>We first need to download the <a href="https://developer.android.com/ndk/">Android NDK</a> since we need the prebuilt gdbserver in it. The NDK is large and we do not need other things in it (for debugging purpose). However, it is better than randomly searching on the Internet for it &ndash; it may not work properly inside the AVD.</p>
<p>The gdbserver can be found in the <code>android-ndk-r21b/prebuilt/android-x86/gdbserver</code>. Note I have a x86 AVD so I need the x86 version of it. First I push it to the device:</p>
<pre><code>$ adb push ./android-ndk-r21b/prebuilt/android-x86/gdbserver /system/bin/
</code></pre><p>After that, I launch the app on the device. Then On my computer, I spawn an adb shell by running:</p>
<pre><code>$ adb shell
</code></pre><p>The app is called <strong>telegram</strong> so I run the following command to find the PID of the target process by running:</p>
<pre><code># ps -A | grep telegram                                                                   
u0_a80        4165  7934 1562976 153292 ep_poll      e9897b59 S org.telegram.messenger
</code></pre><p>Note: I use <code>$</code> for any command to be executed in the host shell and <code>#</code> for anything inside the adb shell.</p>
<p>The PID of our target is 4165. The command to attach gdbserver to the process is:</p>
<pre><code># gdbserver --attach host:port PID
</code></pre><p>In my case, I use:</p>
<pre><code># gdbserver --attach localhost:12345 4165
</code></pre><p>Now the gdbserver will attach to the process with PID 4165 and listen on port 12345 for remote connection. Meanwhile, the app will hang.</p>
<p>We need to set up a port forwarding before connecting to it. This is because the gdbserver is listening on the port 12345 of the device, not our host computer.</p>
<pre><code>$ adb forward tcp:12345 tcp:12345
</code></pre><p>This will forward the port 12345 on the host to the port 12345 on the device.</p>
<p>Now launch gdb on the computer and attach to it:</p>
<pre><code>pwndbg&gt; target remote localhost:12345
</code></pre><p>If everything works fine gdb should be printing a lot of information about the remote target. This might take a while and eventually, it should stop and ask for your input. The prompt starts with <code>pwndbg&gt;</code> because I installed the pwngdb enhancement, which makes gdb more usable.</p>
<p>The next thing to figure out is the base address of the loaded libtmessages.29.so.</p>
<pre><code>pwndbg&gt; info sharedlibrary
From        To          Syms Read   Shared Object Library
// many lines omitted
0xc9b69000  0xc9b6eaf7  Yes (*)     target:/data/app/org.telegram.messenger-o_d807FF7eGAXMhf5s3qqQ==/oat/x86/base.odex
0xc9406570  0xc9406830  Yes (*)     target:/data/app/org.telegram.messenger-o_d807FF7eGAXMhf5s3qqQ==/lib/x86/libtmessages.29.so
0xc8896400  0xc8f70f71  Yes (*)     target:/data/app/org.telegram.messenger-o_d807FF7eGAXMhf5s3qqQ==/lib/x86/libtmessages.28.so
0xc7d329b0  0xc7d36ea5  Yes (*)     target:/vendor/lib/hw/gralloc.ranchu.so
(*): Shared library is missing debugging information.
</code></pre><p>We can see the address of libtmessages.29.so is 0xc9406570. Interestingly, the address reported by <strong>info sharedblibrary</strong> is the address of the <strong>.text</strong> section, which is not very convenient for rebasing. But it is fine since we can calculate it manually.</p>
<p>In BinaryNinja we can see the start of the .text is at 0x5570, while the start of the function is at 0x6871. We now the offset of the remains the same, so the actual address to set the breakpoint is:</p>
<pre><code>&gt;&gt;&gt; hex(0xc9406570 + (0x6871 - 0x5570))
'0xc9407871'
</code></pre><p>. Then we rebase it in BinaryNinja and we now the address of that.</p>
<pre><code>pwndbg&gt; b *0xc9407871
Breakpoint 1 at 0xc9407871
pwndbg&gt; c
Continuing.
</code></pre><p>Now, give a random phone number and hit enter on the phone. And the breakpoint hits! We find the verification function!</p>
<h2 id="solving-the-country-code">Solving the Country Code</h2>
<p>The function is medium-sized and we need to have a big picture of it before plunging into lines of assemblies. Near the bottom of the function, we see the string &ldquo;Wrong number&rdquo; being created in a buffer:</p>
<p><img src="../imgs/wrong_number.png" alt=""></p>
<p>So we need to avoid this basic block. Scrolling up a little bit and we find two checks must be satisfied:</p>
<p><img src="../imgs/key.png" alt=""></p>
<p>These are testing if the lowest bit is set. However, if we go further upward we can find that both <strong>check_1</strong> and <strong>check_2</strong> are booleans and they represent whether a check is satisfied. For check_1, we have the following block:</p>
<p><img src="../imgs/country_code.png" alt=""></p>
<p>We see a string input is passed into function <strong>std::__ndk1::stoul</strong> and converted to an integer using base 10. Then <strong>7 * int + 9</strong> is calculated and the result is fed into function <strong>__umoddi3</strong>. I have seen <strong>__umoddi3</strong> before so I quickly figure out the divisor is 0x25. In fact, <strong>__umoddi3</strong> calculates 64-bit unsigned modulus. This is a 32-bit binary so it has to use two registers to hold 64bit values. The <strong>edx</strong> pushed onto the stack is the higher 32 bits of the dividend; the <strong>eax</strong> is the lower 32bits. If I have not seen it, I can also figure it out by debugging the code and observe the input and output for it. The modulus is returned as <strong>edx:eax</strong> too.</p>
<p>We want variable <strong>check_1</strong> to be 1, so we must set it at 0x6a60. To ensure the <strong>ZF</strong> is set when it gets to 0x6a60, the eax must be 0x17 and the edx must be 0. This means the modulus must be equal to 0x17.</p>
<p>A quick debugging veries the input string is the country code we input. So the constaint here is:</p>
<pre><code>(7 * country_code + 9) % 0x25 == 0x17
</code></pre><p>A simple script to print the accepted coutry_code is as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#66d9ef">for</span> coutry_code <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">999</span>):
    <span style="color:#66d9ef">if</span>  (<span style="color:#ae81ff">7</span> <span style="color:#f92672">*</span> coutry_code <span style="color:#f92672">+</span> <span style="color:#ae81ff">9</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">0x25</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x17</span>:
        <span style="color:#66d9ef">print</span>(coutry_code)
</code></pre></div><p>We know there are many values that satisfy the above equation, but only one among them is a valid country code. It is +39, which is the code for Italy.</p>
<h2 id="solving-the-phone-number">Solving the Phone Number</h2>
<p>Below the country code check, we can find the check for the phone number. At 0x6c6f it calls into another medium-sized function, which is probably the check function. It looks like this:</p>
<p><img src="../imgs/phone_func.png" alt=""></p>
<p>It is not immediately obvious what this function does. Though from the first few basic blocks we can observe the <strong>std::string</strong> being used and the valid length is probably 0x16. Remember the correct phone number is not necessarily a phone number at <strong>al</strong> and it does not have to have a length that looks like a phone number (e.g., 10 digits for the U.S.).</p>
<p>To approach a function like this, there are two methods. The first way is to check how is the return value calculated and back-slice it and do taint-analysis in the brain. From the previous analysis we now this function should return 1 in <strong>eax</strong>. We can go back from the last instruction that touches <strong>eax</strong> and see what is the way to set it to 1.</p>
<p>Besides, we see there is a loop in the lower-right side of the mini graph. Loops can give us a lot of information about what is happening. My way to reverse a loop is to identify the iteration variable (similar to <strong>i</strong> in C code), and see what is the initial value, final value, and stride. Or more generally speaking, what is the exit condition and what is the update rule. This lets us know how many times this loop is going to be executed.</p>
<p>Then we should get into the loop body and analyze it. This lets us know what is done in one iteration. These two combined tell us what the loop is doing as a whole.</p>
<p>It is hard to include every step I took to reverse this loop, but let me describe the major steps.
First thing first, there are many ways to exit this loop, but the exit at 0x7325 is the only place where the return value of this function can be 1. Above it, we see <strong>cmp ecx, esi</strong>, which is probably comparing the iterator with the final value. But which one is the iterator?</p>
<p><img src="../imgs/loop.png" alt=""></p>
<p>In many cases, we can figure out by looking at the code, but for this one, I am not so sure. Never mind, we can debug it. I set a breakpoint at 0x7323 and send an input with length 0x16 (if the length is wrong, the execution never enters the loop). In the first iteration <strong>ecx</strong> is 0 and <strong>esi</strong> is 0x16; in the second iteration <strong>ecx</strong> is 2 and <strong>esi</strong> is 0x16.</p>
<p>So, it looks like ecx is <strong>i</strong> and esi is the final value 0x16. Going up a little bit and at 0x7306 we see the i is incremented by 2 each time. So this loop probably processes two bytes of the input one time.</p>
<p>Now it is time to analyze one iteration. We want the code at <strong>0x732d</strong> to set al, then <strong>edi</strong> must not be 0. At <strong>0x7300</strong> there is a <strong>and</strong>, so ecx must not be 0. <strong>ecx</strong> is updated at 0x72d8, where we have a <strong>cmp</strong> before it. So to have 1 as the return value for the function, this <strong>cmp</strong> must be equal. Then we move further upward to see what is <strong>al</strong> and <strong>byte [esp+0x36]</strong>.</p>
<p><img src="../imgs/loop_body.png" alt=""></p>
<p>It turns out the al is the result of another <strong>std::__ndk1::stoul</strong>. The base is still 10 and the input is the two chars (for every iteration) from the input string. The other operand is a little bit complex. During debugging, I find that at 0x7283, the <strong>eax</strong> points to a string</p>
<pre><code>org.telegram.messenger
</code></pre><p>It is the name of the app. I did not bother backtrace how it gets to here but this is an interesting finding: it is probably used in the algorithm. At 0x7295, it takes the ith char of the above string. At 0x729d, the char (ASCII value) is xor-ed with a variable we do not understand yet.</p>
<p>Then we see a <strong>division by multiplication</strong>. This is an optimization technique used by compilers to speed up divisions. Division instructions (e.g., <strong>idiv</strong>) are super slow to execute so the compilers calculate it differently. Even though we ended up with more instructions, the code executes faster. For more details on this topic, please refer to: <a href="https://stackoverflow.com/questions/30790184/perform-integer-division-using-multiplication">ref 1</a> or <a href="https://gmplib.org/~tege/divcnst-pldi94.pdf">ref 2</a>.</p>
<p>It is not hard to recognize the divisor from the assembly after we know how it works. Furthermore, if the division is used to calculate a modulus, it is easier to recognize. For example, if the code calculates <strong>eax % n</strong>, it will do the following two things:</p>
<pre><code>quotient = eax / n
modulus = eax - quotient * n
</code></pre><p>The &ldquo;divide by n&rdquo; part might not be immediately obvious, but the &ldquo;multiply by n&rdquo; part is super easy.</p>
<pre><code>000072a3  movsx   ecx, byte [esp+0x36 {var_3a_1}]
000072a8  mov     eax, ecx
000072aa  mov     edx, 0x51eb851f
000072af  imul    edx
000072b1  mov     eax, edx
000072b3  shr     eax, 0x1f
000072b6  shr     edx, 0x5
000072b9  add     edx, eax
000072bb  imul    eax, edx, 0x64
000072be  sub     ecx, eax
000072c0  mov     byte [esp+0x36 {xored_val % 0x64}], cl
</code></pre><p>At 0x72bb we see a <strong>imul    eax, edx, 0x64</strong> followed by a <strong>sub     ecx, eax</strong>. Obviously, this is calculating the modules and divisor is 0x64. So this whole thing is calculating <strong>ecx % 0x64</strong>.</p>
<p>For many other divisor values, the multiplication will be further optimized. Like if the divisor is 9, it will become something like <strong>mov edx, eax; shl edx, 3; add edx, eax</strong>. But the &ldquo;shift left and add&rdquo; trick is still more obvious than the division.</p>
<p>Now the only missing piece is the mysterious variable referenced at address 0x7299. Notice it is initialized to 0 before entering the loop and update at 0x72c9 according to the result of the transformation in each iteration. In fact, this is similar to the <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation">Cipher block chaining (CBC)</a> in block ciphers, where an initilization vector is provided and updated on every block.</p>
<p>We can now reconstruct the algorithm as the following pseudo-code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">check</span>(input_string):
    <span style="color:#66d9ef">if</span> len(input_string) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0x16</span>:
        <span style="color:#66d9ef">return</span> False

    s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;org.telegram.messenger&#39;</span>
    IV <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    check_ok <span style="color:#f92672">=</span> True
    <span style="color:#66d9ef">for</span> i, two_char <span style="color:#f92672">in</span> yield_two_char_every_time(input_string):
        val <span style="color:#f92672">=</span> int(two_char, <span style="color:#ae81ff">10</span>)
        IV <span style="color:#f92672">=</span> (IV <span style="color:#f92672">^</span> i <span style="color:#f92672">^</span> asc(s[i])) <span style="color:#f92672">%</span> <span style="color:#ae81ff">0x64</span>
        <span style="color:#66d9ef">if</span> val <span style="color:#f92672">!=</span> IV:
            check_ok <span style="color:#f92672">=</span> False
            <span style="color:#66d9ef">break</span>
    <span style="color:#66d9ef">return</span> check_ok
</code></pre></div><p>Which can be solved by the following script:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python">s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;org.telegram.messenger&#39;</span>
val <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
flag <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;</span>
<span style="color:#66d9ef">while</span> i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0x16</span>:
    c <span style="color:#f92672">=</span> s[i]
    asc <span style="color:#f92672">=</span> val <span style="color:#f92672">^</span> i <span style="color:#f92672">^</span> ord(c)
    asc <span style="color:#f92672">%=</span> <span style="color:#ae81ff">0x64</span>
    val <span style="color:#f92672">=</span> asc
    flag <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> asc
    i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>

<span style="color:#66d9ef">print</span>(flag)
<span style="color:#75715e"># the flag is:</span>
<span style="color:#75715e"># 1110222419205493626651</span>
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>Solving a Reversing Challenge with Mitmproxy and OCR</title>
            <link>/posts/reversing/client_houseplant_ctf_2020/solve/</link>
            <pubDate>Mon, 27 Apr 2020 00:00:00 +0000</pubDate>
            
            <guid>/posts/reversing/client_houseplant_ctf_2020/solve/</guid>
            <description>Over the weekend I had some fun with the Houseplant CTF. Among the reversing challenges, the RTCP Trivia is particularly interesting and I would like to share my unconventional way of solving it.
First Impression We get a client.apk after downloading the challenge. I have no Android phones so I ran it in an emulator. It has no ARM native library so it runs well in x86 emulators.
After asking for a user name, the app presents a multiple-choice problem with four options (shown below).</description>
            <content type="html"><![CDATA[<p>Over the weekend I had some fun with the <a href="https://houseplant.riceteacatpanda.wtf/home">Houseplant CTF</a>. Among the reversing challenges, the <a href="https://houseplant.riceteacatpanda.wtf/challenge?id=8"><strong>RTCP Trivia</strong></a> is particularly interesting and I would like to share my unconventional way of solving it.</p>
<h2 id="first-impression">First Impression</h2>
<p>We get a <a href="../client.apk"><strong>client.apk</strong></a> after downloading the challenge. I have no Android phones so I ran it in an emulator. It has no ARM native library so it runs well in x86 emulators.</p>
<p>After asking for a user name, the app presents a multiple-choice problem with four options (shown below). The problem itself is not difficult. However, there is a ten-second countdown and we must answer it before the time elapses. The challenge description says that we need to correctly answer 1000 such problems. So manual solving is probably not a wise idea.</p>
<p><img src="../imgs/1.png" alt=""></p>
<h2 id="inspecting-the-traffic">Inspecting the Traffic</h2>
<p>After I unzipped the apk and inspected the files inside of it, I found the challenges are not stored inside the apk. I confirmed this by cutting the network to the emulator &ndash; it no longer shows new challenges or tells you the answer is wrong.</p>
<p>I inspected the resources of this app and found the real flag is not there (a fake flag can be found in the strings). So it probably comes from the server after we solve 1000 problems.</p>
<p>I then launched Wireshark to have a look at the traffic. The app uses websocket to communicate with the server. The problem is sent from the server and the choice is submitted to the server. So the logic is not local. But I quickly notice something strange:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JSON" data-lang="JSON">{
    <span style="color:#f92672">&#34;method&#34;</span>: <span style="color:#e6db74">&#34;question&#34;</span>,
    <span style="color:#f92672">&#34;id&#34;</span>: <span style="color:#e6db74">&#34;30a3956f-cd60-4c51-bc01-dbbf1b09f9b0&#34;</span>,
    <span style="color:#f92672">&#34;questionText&#34;</span>: <span style="color:#e6db74">&#34;S62ZtWoNqto0jxuZalalAmv4s/n2GmaTai5Z7/bVsk6W48CbtUvYcOyVRi7qcPeP&#34;</span>,
    <span style="color:#f92672">&#34;options&#34;</span>: [
        <span style="color:#e6db74">&#34;bNMO3oWCI/s5OHBEiXfgkg==&#34;</span>,
        <span style="color:#e6db74">&#34;qpDFxRVJXyczm52QbPTa8A==&#34;</span>,
        <span style="color:#e6db74">&#34;8UQQMs42vvLpLIq0wNEIaw==&#34;</span>,
        <span style="color:#e6db74">&#34;cLYF4H6LVlIi3YPF3R4MUg==&#34;</span>
    ],
    <span style="color:#f92672">&#34;correctAnswer&#34;</span>: <span style="color:#e6db74">&#34;mboZgfosD3S1ZUf330zmxaeq+bR2vzKkCV2AKOB8vlA=&#34;</span>,
    <span style="color:#f92672">&#34;requestIdentifier&#34;</span>: <span style="color:#e6db74">&#34;f814ce11519a16be435ac73bc0e89238&#34;</span>
}
</code></pre></div><p>Despite most data are encrypted, we see that the <strong>correctAnswer</strong> is also sent to the client. This means if we can decrypt it, we get the correct answer. And we know the app can decrypt the questionText and options, since it needs to show them to us. It is highly likely that the answer is encrypted in the same way and we can also decrypt it.</p>
<h2 id="reversing-the-algorithm-no">Reversing the Algorithm? No!</h2>
<p>A routine way to solve this is: 1). reverse the app to find out the encryption algorithm; 2). rewrite a client to communicate with the server. I did not take this approach since: 1). although it is easy to find out the encryption algorithm is AES and the iv is indeed requestIdentifier, it is not immediately clear how is the key generated. 2). I mistakenbly think the traffic sent from the client to the server is encrypted using a custom crypto (which later turns out to be just compression). These two obstacles are not prohibiting me from solving it, but I think it will take longer than I expected, so I decide to try a novel method.</p>
<p>After reading how the app displays the question text, I found that if I swap the keyword &ldquo;questionText&rdquo; with &ldquo;requestIdentifier&rdquo; in the json, the correct answer will be displayed on the screen!</p>
<p>Since the traffic is plaintext websocket, it is quite easy to implement it. I first tried Burp but it does not support match-and-replace in websocket. Then I used <a href="https://mitmproxy.org/">mitmproxy</a>. Mitmproxy allows us to script in Python, so we can easily modify the traffic.</p>
<p>I copy-and-pasted one example from the official repo and made some changes. The following code will change <code>'correctAnswer'</code> to <code>'questionText'</code> and change <code>'questionText'</code> to <code>'replaced'</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#f92672">from</span> mitmproxy <span style="color:#f92672">import</span> ctx
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">websocket_message</span>(flow):

    message <span style="color:#f92672">=</span> flow<span style="color:#f92672">.</span>messages[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]

    <span style="color:#66d9ef">if</span> message<span style="color:#f92672">.</span>from_client:
        ctx<span style="color:#f92672">.</span>log<span style="color:#f92672">.</span>info(<span style="color:#e6db74">&#34;Client sent a message: {}&#34;</span><span style="color:#f92672">.</span>format(message<span style="color:#f92672">.</span>content))
    <span style="color:#66d9ef">else</span>:
        ctx<span style="color:#f92672">.</span>log<span style="color:#f92672">.</span>info(<span style="color:#e6db74">&#34;Server sent a message: {}&#34;</span><span style="color:#f92672">.</span>format(message<span style="color:#f92672">.</span>content))

    <span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#39;correctAnswer&#39;</span> <span style="color:#f92672">in</span> message<span style="color:#f92672">.</span>content:

        message<span style="color:#f92672">.</span>content <span style="color:#f92672">=</span> message<span style="color:#f92672">.</span>content<span style="color:#f92672">.</span>replace(<span style="color:#e6db74">&#39;questionText&#39;</span>, <span style="color:#e6db74">&#39;replaced&#39;</span>)
        message<span style="color:#f92672">.</span>content <span style="color:#f92672">=</span> message<span style="color:#f92672">.</span>content<span style="color:#f92672">.</span>replace(<span style="color:#e6db74">&#39;correctAnswer&#39;</span>, <span style="color:#e6db74">&#39;questionText&#39;</span>)
</code></pre></div><p>Mitmproxy scripts are not meant to run on its own. Instread, we should run tools from mitmrpoxy and specify it with the <code>-s</code> option:</p>
<pre><code>mitmdump -s ./mitm-solve.py
</code></pre><p>And it works! Now instead of the question text, the app shows the index of the correct answer to us.</p>
<p><img src="../imgs/2.png" alt=""></p>
<p>I tried to solve it by hand. But even if I have the correct answer, I still cannot stop clicking the wrong button. I do not want to solve it as an action game, so I start to seek viable ways to automate the solving.</p>
<p>The good thing is, mitmproxy allows us to inject packets. And thanks to the nature of websocket, this will not disrupt the communicaition between the client and the server. So the last problem is how to get the correct answer. Reversing the crypto algorithm is always an option, but I decide not to do it for this time.</p>
<h2 id="solving-a-reversing-challenge-with-ocr">Solving a Reversing Challenge with OCR</h2>
<p>It quickly pops up my mind that I can use OCR to recognize the correct answer. Does it work? I have not really done it before. Nevertheless the workflow is really simple: 1). capture a screenshot and crop it to the desired region. 2). use some OCR tool to recognize it.</p>
<p>I use <strong>pyautogui</strong> to capture a screenshot of my laptop screen. I already measured the bounding box of the answer digit with gimp. Then I just crop it accordingly. It feels like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python">image <span style="color:#f92672">=</span> pyautogui<span style="color:#f92672">.</span>screenshot()
image <span style="color:#f92672">=</span> image<span style="color:#f92672">.</span>crop((<span style="color:#ae81ff">1540</span>, <span style="color:#ae81ff">430</span>, <span style="color:#ae81ff">1560</span>, <span style="color:#ae81ff">465</span>))
</code></pre></div><p>After that I used a well-known open-source OCR engine <a href="https://github.com/tesseract-ocr/tesseract">tesseract</a> to recognize the digit on it. I have not used it before but it is quite reliable (at least for our super easy case).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python">txt <span style="color:#f92672">=</span> pytesseract<span style="color:#f92672">.</span>image_to_string(image, 
    config <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;--psm 10 --oem 3 -c tessedit_char_whitelist=0123&#39;</span>)
</code></pre></div><p>The config option is found on the Stackoverflow and I do not really understand it. But it works!</p>
<p><img src="../imgs/4.png" alt="digits"></p>
<p>Now that it comes to the last step: injecting the solution. Note we need to first do the keyword swap, let the traffic reach the client app, wait for the answer to be displayed on the screen, and then read it and inject it. In my script, I waited 0.5 seconds to start the recognition.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Python" data-lang="Python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solve_and_inject</span>(flow):
    <span style="color:#66d9ef">global</span> i 
    time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">0.5</span>)
    ans <span style="color:#f92672">=</span> recognize_char()
    sol <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#39;method&#39;</span> : <span style="color:#e6db74">&#39;answer&#39;</span>, <span style="color:#e6db74">&#39;answer&#39;</span> : ans}
    <span style="color:#66d9ef">print</span>(sol)
    sol_str <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>dumps(sol)
    flow<span style="color:#f92672">.</span>inject_message(flow<span style="color:#f92672">.</span>server_conn, sol_str)
    i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;solved: </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> i)
</code></pre></div><p>Alright, it now works! Wait for some 20 minutes and we get the flag: rtcp{qu1z_4pps_4re_c00l_aeecfa13}.</p>
<p><img src="../imgs/3.png" alt=""></p>
<p>I actually recorded a <a href="https://youtu.be/Acp8PDbsvQk">video</a> to demonstrate the solving.</p>
<p><a href="https://youtu.be/Acp8PDbsvQk" title="Video"><img src="../imgs/video.png" alt="Video"></a></p>
]]></content>
        </item>
        
        <item>
            <title>Reverse Engineering and Repairing a Fan</title>
            <link>/posts/reversing/reverse_engineering_and_fixing_a_fan/main/</link>
            <pubDate>Sun, 26 Apr 2020 00:00:00 +0000</pubDate>
            
            <guid>/posts/reversing/reverse_engineering_and_fixing_a_fan/main/</guid>
            <description>Last summer, I broke a fan and managed to repair it. Although the repairing process is not so exciting, I recently find it can serve as a good example to explain a reverser&amp;rsquo;s mindset. Like how I approached the problem and solved it. I hope to share some of my understanding about reverse engineering in this writeup.
A Broken Fan I have a fan &amp;ndash; an eight-year-old fan &amp;ndash; that is NOT smart or IoT.</description>
            <content type="html"><![CDATA[<p>Last summer, I broke a fan and managed to repair it. Although the repairing process is not so exciting, I recently find it can serve as a good example to explain a reverser&rsquo;s mindset. Like how I approached the problem and solved it. I hope to share some of my understanding about reverse engineering in this writeup.</p>
<h2 id="a-broken-fan">A Broken Fan</h2>
<p>I have a fan &ndash; an eight-year-old fan &ndash; that is NOT smart or IoT. It is just a simple fan. One day it fell from the table to the ground and stopped working. <em>RIP</em>. It accompanied me for several summers and I love it. I decided to take it apart and see what is indeed broken, before saying farewell to my friend.</p>
<p>I know little about electronics, but a fan should not be too complex. It looks like this after I opened it:</p>
<p><img src="../imgs/img-1.jpg" alt=""></p>
<p>We can see the fan blades, the power cord, the timer, and the ON/OFF switch in it. It looks all in good shape despite the impact. How should I start reversing it?</p>
<p>I quickly notice there is a small metal cylinder that is moving freely in the fan closure. Normally we do not have such small moving parts in a fan (it will clash with the blade easily). It is probably broken apart from the fan due to the impact. It is a reasonable guess. But how could I prove it or refute it?</p>
<p><img src="../imgs/img-2.jpg" alt=""></p>
<p>I decided to see other parts of the fan. The logic is, if the cylinder breaks apart from somewhere, there should be a trace of it. I then spotted a previously unnoticed part. It is a plastic box and there is a sharp irregular edge on it, which is a sign of a broken part. I have no idea what the box is and it does not look critical to the fan&rsquo;s functionality, since I already identified the timer and the switch, etc.</p>
<h2 id="making-the-fan-alive-again">Making the Fan Alive Again!</h2>
<p>Upon closer inspection of the plastic box, I see two wires going into it and the wires are connected to small metal blades. One weird thing is the blades are <strong>NOT</strong> connected. And they are likely to remain unconnected during the operation of the fan. What is this?</p>
<p>Now it becomes interesting: I have examined most parts of the fan, and found stuff that worth investigating. I need to connect the dots. Some creativity, as well as luck, are needed here. I stared at the plastic box and the cylinder for a while, and I suddenly <strong>have a hypothesis</strong>. If I put this metal cylinder inside the plastic box, the blades will be connected. Could it be the reason that the fan stopped working?</p>
<p><img src="../imgs/img-3.jpg" alt=""></p>
<p>I did a quick test: I put the cylinder inside it and turned the switch on. Wow, it works! The fan is alive again!</p>
<h2 id="why-is-there-a-plastic-box-and-a-metal-cylinder">Why is there a Plastic Box and a Metal Cylinder?</h2>
<p>Not all of the mysteries are solved yet. I am still puzzled by this plastic box and the metal cylinder. What is the purpose of having them? What did they look like before the fall?</p>
<p>Now it comes to the fundamental part of reverse engineering: <strong>understanding how the system works</strong>. The fan works but it is quite weird: this plastic box can be removed and we just connect the two wires directly. There must be a reason to have it.</p>
<p>There are two ways to reason about it in such a situation. The first way is to think of what could go wrong if we do not have it. Like why we need to check whether the divisor is zero before we divide. However, as mentioned above, nothing seems wrong without this box. This method does not work here. It must be serving <strong>certain purpose yet unknown</strong> to us. This is quite a typical scenario in reverse engineering.</p>
<p>The other way is to imagine different inputs to the system (the fan), and predict the possible status or outcomes of the system. Then we deduce the purpose of it. This is harder to do because we need to generate lots of inputs and examine many possible status or outcomes. And it is not guaranteed to succeed! It could be purposed for a situation we could never think of, so we would never know why it is here.</p>
<p>Let us start with it. The cylinder currently connects the two metal blades. What would stop it from doing so? Not too hard, right? If it leaves the current position and goes up, the blades are disconnected. However, due to gravity, it will not move up by itself. Can we come up with a case where the gravity does not moderate this cylinder? Well, if this fan is used in the space station then the cylinder can move freely. But it is not the case here. It is a consumer product. What could be another case where the effect of gravity is gone or altered?</p>
<p><strong>WHEN IT FALLS!</strong></p>
<p>When the fan falls, the gravity will no longer drag the cylinder toward the position that connects the two blades. The result is, the cylinder moves, leaving the two blads disconnected, and the fan stops working. Now we have a reasonable explanation for the plastic part and the metal cylinder: it is a <strong>fall-protection mechanism</strong>!</p>
<h2 id="connecting-the-dots">Connecting the Dots</h2>
<p>Note the cylinder can not only move vertically, but it can also move horizontally. It can leave the plastic box and never (easily) get back. In fact, this is probably the cause of the fan&rsquo;s failure. We still miss something.</p>
<p>I did not guess it, though some readers could already guessed it. I examined the fan again and found another plastic piece in it. It looks like a lid for the plastic box. If there is a lid, then the cylinder will not leave the plasitc box. And in case of the fan falls, once it is erected again, the cylinder will go back to its original position and connect the blades again.</p>
<p>All the dots are eventually connected. The metal cylinder was confined in a plastic box. It serves as a fall protection mechanism. However, the fan fell from a high desk and the impact was so strong that the cylinder broke the plastic box apart. (We can see the lid was somehow connected to the box before it broke.) It is unable to go back to its original position again and the fan stopped working.</p>
<p>I have to admit this is quite simple yet effective. If I were to implement such functionality, what comes to my mind first is gyroscopes and a program, which is both complex and expensive. Through reverse enginnering,  I learned the same thing can be achieved like this.</p>
<p>It eventyally comes to the last step in reverse engineering. We need to repair the fan. For this particular one, it is not hard to repair. We first put the cylinder inside the box, then put the lid on top of the box, and then use some tape to secure it. It looks like this after it is repaired:</p>
<p><img src="../imgs/img-4.jpg" alt=""></p>
<h2 id="relating-to-reverse-engineering">Relating to Reverse Engineering</h2>
<p>I admit this example of reverse engineering the fall-protection mechanism and repairing the fan is trivial. However, it does show some important steps in reverse engineering. Let me explain.</p>
<p>In the first step, I opened the fan to see its internal. This is analogous to analyzing a binary statically. I did some preliminary analysis on the fan, like identifying the core components. In reverse engineering, we do this too. Typically we would have a quick look at the binary to get some information about it. Like what platform it runs on and what API functions it calls.</p>
<p>Then I spotted a metal cylinder that moves freely. This is called (by me) a <strong>pivot</strong>. A binary program can be huge and we cannot blindly reverse it entirely. We need to focus on something. It could be a string, an API function, or a constant value (in crypto function).</p>
<p>From the cylinder, I investigated the fan and came up with a possible <strong>hypothesis</strong> for it. I tested it by putting the cylinder back and turn the fan on. Then the hypothesis is confirmed. This loop is quite common in real-world reverse engineering. For example, there is a function that we are not sure about. We could study it and get several possible guesses for it. Then we confirm or refute them. What I did is most close to <strong>debugging</strong>, where I launch the fan and see if it works. I am lucky since my first hypothesis is correct. In reversing this loop could repeat several times before one understands a complex function.</p>
<p>Now it comes to the hard part. I did not immediately understand why there are such a plastic box and a cylinder. This is also common in reverse engineering. We encounter lots of things that we cannot properly understand or guess their meaning. The approach I took can be understood as a <strong>symbolic execution</strong> of the fan. I tried to reason about what could happen to the fan in a different scenario. While doing this, <strong>constriant solving</strong> is quite helpful as it gave me several cases of why the cylinder could move. Symbolic execution and constraint solving are intermediate topics in reverse engineering. They could look like <em>magic</em> in many cases.</p>
<p>After I get a comprehensive understanding of the fan, I need to repair it. In reverse engineering, most likely we do not need to repair anything (well, in certain cases we need to fix a bug in the binary, but that is rare). We need to re-implement it, either as code or documentation.</p>
<p>The above can be summarized in the following chart:</p>
<table>
<thead>
<tr>
<th>Repairing a fan</th>
<th>Reverse Enginnering</th>
</tr>
</thead>
<tbody>
<tr>
<td>take the fan apart</td>
<td>static analysis</td>
</tr>
<tr>
<td>spot the cylinder</td>
<td>find a pivot</td>
</tr>
<tr>
<td>guess the cylinder can connect the circuit</td>
<td>have a hypothesis</td>
</tr>
<tr>
<td>put the cylinder back and turn the fan on</td>
<td>test the hypothesis (debugging)</td>
</tr>
<tr>
<td>reason about the plastic box&rsquo;s functionality</td>
<td>symbolic execution &amp; constraint solving</td>
</tr>
<tr>
<td>understand it is fall protection mechanism</td>
<td>understand the functionality of code</td>
</tr>
<tr>
<td>repair the fan</td>
<td>reimplement as code or documentation</td>
</tr>
</tbody>
</table>
<p>Of course, this analogy is not meant to be complete or always accurate. For example, debugging is only one of the ways to test the hypothesis. And we do not explicitly use symbolic execution and constraint solving every time we reverse. An interesting fact is, when we reason about a piece of code, we probably symbolically executed it many times <strong>in our mind</strong> without using any external tools like Triton or angr.</p>
]]></content>
        </item>
        
        <item>
            <title>排局-20</title>
            <link>/posts/xiangqi/2018-05-06-endgame-20/</link>
            <pubDate>Sun, 06 May 2018 16:19:08 +0800</pubDate>
            
            <guid>/posts/xiangqi/2018-05-06-endgame-20/</guid>
            <description> 车八退一 士４进５ 车八平六 士５进４ 炮八进九 马５退４ 炮八退三 马４进３ 马九退七 将５平４ 兵四平五 炮７平５ 炮八进三 象３进５ 兵五进一 将４进１ 炮八退一  </description>
            <content type="html"><![CDATA[<p><img src="../imgs/2018/05/capture-24.png" alt=""></p>
<ol>
<li>车八退一 士４进５</li>
<li>车八平六 士５进４</li>
<li>炮八进九 马５退４</li>
<li>炮八退三 马４进３</li>
<li>马九退七 将５平４</li>
<li>兵四平五 炮７平５</li>
<li>炮八进三 象３进５</li>
<li>兵五进一 将４进１</li>
<li>炮八退一</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>排局-19</title>
            <link>/posts/xiangqi/2018-05-06-endgame-19/</link>
            <pubDate>Sun, 06 May 2018 16:10:59 +0800</pubDate>
            
            <guid>/posts/xiangqi/2018-05-06-endgame-19/</guid>
            <description> 炮六平八 士４进５ 马四进五! 士５进４ 马五进六!  </description>
            <content type="html"><![CDATA[<p><img src="../imgs/2018/05/capture-1-3.png" alt=""></p>
<ol>
<li>炮六平八 士４进５</li>
<li>马四进五! 士５进４</li>
<li>马五进六!</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>排局-18</title>
            <link>/posts/xiangqi/2018-05-06-endgame-18/</link>
            <pubDate>Sun, 06 May 2018 16:06:56 +0800</pubDate>
            
            <guid>/posts/xiangqi/2018-05-06-endgame-18/</guid>
            <description> 兵六平五 炮７平５ 兵三平四 马５退６ 马一进二 车７退７ 炮七进一 士５退４ 马四进六 士４退５ 炮七退七  由此红方转为进攻黑方底士，此亦本局取名《峰回路转》之意。
&amp;hellip;&amp;hellip; 车７平８ 炮七平六 车８进６ 炮六平二 马８退７ 炮二进一 马７进９  如马7退6，炮二平四，困毙红胜
炮二平六 马９进７ 帅四退一 马７退８ 帅四进一 马８退７ 帅四退一 马７进５ 帅四进一 马５退４ 炮六进一 马４退３ 炮六进三 马３退２ 炮六进二 红胜  </description>
            <content type="html"><![CDATA[<p><img src="../imgs/2018/05/capture-21.png" alt=""></p>
<ol>
<li>兵六平五 炮７平５</li>
<li>兵三平四 马５退６</li>
<li>马一进二 车７退７</li>
<li>炮七进一 士５退４</li>
<li>马四进六 士４退５</li>
<li>炮七退七</li>
</ol>
<p>由此红方转为进攻黑方底士，此亦本局取名《峰回路转》之意。</p>
<ol start="6">
<li>&hellip;&hellip;        车７平８</li>
<li>炮七平六 车８进６</li>
<li>炮六平二 马８退７</li>
<li>炮二进一 马７进９</li>
</ol>
<p>如马7退6，炮二平四，困毙红胜</p>
<ol start="10">
<li>炮二平六 马９进７</li>
<li>帅四退一 马７退８</li>
<li>帅四进一 马８退７</li>
<li>帅四退一 马７进５</li>
<li>帅四进一 马５退４</li>
<li>炮六进一 马４退３</li>
<li>炮六进三 马３退２</li>
<li>炮六进二 红胜</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>排局-17</title>
            <link>/posts/xiangqi/2018-05-06-endgame-17/</link>
            <pubDate>Sun, 06 May 2018 15:31:13 +0800</pubDate>
            
            <guid>/posts/xiangqi/2018-05-06-endgame-17/</guid>
            <description> 帅六退一 士５进６ 兵五平四 将４退１ 炮五平七 将４进１ 炮七平四 将４平５ 炮四退一 将５平４ 炮四平五 士６退５ 兵四平五 士５退６ 炮五进一 士６进５ 炮五平六  </description>
            <content type="html"><![CDATA[<p><img src="../imgs/2018/05/capture-20.png" alt=""></p>
<ol>
<li>帅六退一 士５进６</li>
<li>兵五平四 将４退１</li>
<li>炮五平七 将４进１</li>
<li>炮七平四 将４平５</li>
<li>炮四退一 将５平４</li>
<li>炮四平五 士６退５</li>
<li>兵四平五 士５退６</li>
<li>炮五进一 士６进５</li>
<li>炮五平六</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>排局-16</title>
            <link>/posts/xiangqi/2018-05-06-endgame-16/</link>
            <pubDate>Sun, 06 May 2018 15:30:08 +0800</pubDate>
            
            <guid>/posts/xiangqi/2018-05-06-endgame-16/</guid>
            <description> 兵九平八 将４进１ 兵八平七 将４退１ 帅五退一 象３进１ 马七进八 象１进３ 兵七进一 将４退１ 马八进七 象３退５ 兵七平六 将４平５ 马七退五 车１退１ 仕六退五 车１平４ 马五进四 将５平６ 兵六平五 车４退２ 马四进二  </description>
            <content type="html"><![CDATA[<p><img src="../imgs/2018/05/capture-18.png" alt=""></p>
<ol>
<li>兵九平八 将４进１</li>
<li>兵八平七 将４退１</li>
<li>帅五退一 象３进１</li>
<li>马七进八 象１进３</li>
<li>兵七进一 将４退１</li>
<li>马八进七 象３退５</li>
<li>兵七平六 将４平５</li>
<li>马七退五 车１退１</li>
<li>仕六退五 车１平４</li>
<li>马五进四 将５平６</li>
<li>兵六平五 车４退２</li>
<li>马四进二</li>
</ol>
<p><img src="../imgs/2018/05/capture-19.png" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>排局-15</title>
            <link>/posts/xiangqi/2018-05-06-endgame-15/</link>
            <pubDate>Sun, 06 May 2018 15:27:58 +0800</pubDate>
            
            <guid>/posts/xiangqi/2018-05-06-endgame-15/</guid>
            <description></description>
            <content type="html"><![CDATA[<p><img src="../imgs/2018/05/capture-16.png" alt=""></p>
<p><img src="../imgs/2018/05/capture-17.png" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>排局-14</title>
            <link>/posts/xiangqi/2018-05-06-endgame-14/</link>
            <pubDate>Sun, 06 May 2018 15:25:19 +0800</pubDate>
            
            <guid>/posts/xiangqi/2018-05-06-endgame-14/</guid>
            <description> 车四平六 将４平５ 车六平五 将５平６ 相五进三 车７平６ 车五平二 将６退１ 帅五平六 车６平９ 车二进五 将６退１ 车二退八 车９平７ 车二进三 车７平９ 帅六进一 车９进１ 帅六进一 车９平２ 帅六平五 车２退２ 仕五进六 车２退６ 车二进六 将６进１ 车二退一 将６退１ 车二平八  </description>
            <content type="html"><![CDATA[<p><img src="../imgs/2018/05/capture-14-1.png" alt=""></p>
<ol>
<li>车四平六 将４平５</li>
<li>车六平五 将５平６</li>
<li>相五进三 车７平６</li>
<li>车五平二 将６退１</li>
<li>帅五平六 车６平９</li>
<li>车二进五 将６退１</li>
<li>车二退八 车９平７</li>
<li>车二进三 车７平９</li>
<li>帅六进一 车９进１</li>
<li>帅六进一 车９平２</li>
<li>帅六平五 车２退２</li>
<li>仕五进六 车２退６</li>
<li>车二进六 将６进１</li>
<li>车二退一 将６退１</li>
<li>车二平八</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>排局-13</title>
            <link>/posts/xiangqi/2018-05-06-endgame-13/</link>
            <pubDate>Sun, 06 May 2018 15:23:59 +0800</pubDate>
            
            <guid>/posts/xiangqi/2018-05-06-endgame-13/</guid>
            <description> 炮九平六 士５进４ 仕六退五 车４平５ 炮六平八 卒６平７ 炮八退八 卒７平６ 帅五平六 士４退５ 炮八进四 卒６平７ 炮八平五 卒７平６ 炮五平一 卒６平７ 炮一退四 卒７平６ 相九进七 将６进１ 相七退五 将６退１ 炮一进四 卒６平７ 炮一平八 卒７平６ 炮八退四 将６进１ 仕五退四 车５平６ 炮八平四  </description>
            <content type="html"><![CDATA[<p><img src="../imgs/2018/05/capture-13-1.png" alt=""></p>
<ol>
<li>炮九平六 士５进４</li>
<li>仕六退五 车４平５</li>
<li>炮六平八 卒６平７</li>
<li>炮八退八 卒７平６</li>
<li>帅五平六 士４退５</li>
<li>炮八进四 卒６平７</li>
<li>炮八平五 卒７平６</li>
<li>炮五平一 卒６平７</li>
<li>炮一退四 卒７平６</li>
<li>相九进七 将６进１</li>
<li>相七退五 将６退１</li>
<li>炮一进四 卒６平７</li>
<li>炮一平八 卒７平６</li>
<li>炮八退四 将６进１</li>
<li>仕五退四 车５平６</li>
<li>炮八平四</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>排局-12</title>
            <link>/posts/xiangqi/2018-05-06-endgame-12/</link>
            <pubDate>Sun, 06 May 2018 15:21:12 +0800</pubDate>
            
            <guid>/posts/xiangqi/2018-05-06-endgame-12/</guid>
            <description> 马七退五 将６退１ 马五进三 将６进１ 马三退一 士５退４ 前马退二 将６退１ 马一进二 将６平５ 帅五平六 象５进７ 后马退四 象７退９ 马四退二 将５进１ 后马进三 将５平６ 马三进二 将６平５ 后马进四 象９进７ 马四退三 将５退１ 马二退一 象３进５ 马一进三 将５平６ 前马进二 将６平５ 马二退四 象５退３ 马四退五 象７退９ 马五进七  </description>
            <content type="html"><![CDATA[<p><img src="../imgs/2018/05/capture-12-1.png" alt=""></p>
<ol>
<li>马七退五 将６退１</li>
<li>马五进三 将６进１</li>
<li>马三退一 士５退４</li>
<li>前马退二 将６退１</li>
<li>马一进二 将６平５</li>
<li>帅五平六 象５进７</li>
<li>后马退四 象７退９</li>
<li>马四退二 将５进１</li>
<li>后马进三 将５平６</li>
<li>马三进二 将６平５</li>
<li>后马进四 象９进７</li>
<li>马四退三 将５退１</li>
<li>马二退一 象３进５</li>
<li>马一进三 将５平６</li>
<li>前马进二 将６平５</li>
<li>马二退四 象５退３</li>
<li>马四退五 象７退９</li>
<li>马五进七</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>排局-11</title>
            <link>/posts/xiangqi/2018-05-06-endgame-11/</link>
            <pubDate>Sun, 06 May 2018 15:19:51 +0800</pubDate>
            
            <guid>/posts/xiangqi/2018-05-06-endgame-11/</guid>
            <description> 马六退七 将５退１ 马七进八 象１进３ 相九进七 象３退１ 帅四退一 象１进３ 相七退五 象３退１ 帅四平五 象１进３ 帅五平六 象３退１ 帅六退一 象１进３ 炮九退一 将５进１ 马八退七 将５平６ 马七进六 将６平５ 炮九退七 将５退１ 炮九平五 象３退５ 相五进七 象５进７ 马六退五 象３进５ 马五进三 将５平６ 炮五进八  </description>
            <content type="html"><![CDATA[<p><img src="../imgs/2018/05/capture-11-1.png" alt=""></p>
<ol>
<li>马六退七 将５退１</li>
<li>马七进八 象１进３</li>
<li>相九进七 象３退１</li>
<li>帅四退一 象１进３</li>
<li>相七退五 象３退１</li>
<li>帅四平五 象１进３</li>
<li>帅五平六 象３退１</li>
<li>帅六退一 象１进３</li>
<li>炮九退一 将５进１</li>
<li>马八退七 将５平６</li>
<li>马七进六 将６平５</li>
<li>炮九退七 将５退１</li>
<li>炮九平五 象３退５</li>
<li>相五进七 象５进７</li>
<li>马六退五 象３进５</li>
<li>马五进三 将５平６</li>
<li>炮五进八</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>排局-10</title>
            <link>/posts/xiangqi/2018-05-06-endgame-10/</link>
            <pubDate>Sun, 06 May 2018 15:09:32 +0800</pubDate>
            
            <guid>/posts/xiangqi/2018-05-06-endgame-10/</guid>
            <description>&lt;p&gt;&lt;img src=&#34;../imgs/2018/05/capture-3-2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p><img src="../imgs/2018/05/capture-3-2.png" alt=""></p>
<ol>
<li>车七平四 将６平５</li>
<li>车四平二 马３退２</li>
</ol>
<p>起手红方不吃马，而是照将然后平二，威胁抽车。黑车位置尴尬，只有回马防守。</p>
<ol start="3">
<li>帅五平四 将５退１</li>
<li>车二进三 将５进１</li>
</ol>
<p>红方出帅，意图控制肋道。黑方车马士四子均动弹不得。如果黑方将5平6，则红方顺势车二平四，将6平5，士四退五，以下胜法相似。</p>
<ol start="5">
<li>仕四退五 卒４平5</li>
</ol>
<p>红方落士露将，并且捉吃黑卒。黑如不逃卒，改走将5进1，则红方车二退二，再吃掉黑卒，获胜更容易。</p>
<ol start="6">
<li>车二平四 将５进１</li>
<li>车四退二 将５退１</li>
</ol>
<p>红方控住黑方五子，黑方只有上下老将。红方一车之力虽然不能直接将杀，但暗中扬相，上帅，夺取中路。</p>
<ol start="8">
<li>相五进七 将５退１</li>
<li>车四进二 将５进１</li>
<li>帅四进一 将５进１</li>
</ol>
<p>红帅升到楼顶，此时黑将亦在顶楼，时机成熟，红方果断退车叫杀。</p>
<ol start="11">
<li>车四退四 士４退５</li>
<li>车四平五 将５平４</li>
<li>帅四平五 车４平１</li>
<li>车五平六 白脸将杀，红胜！</li>
</ol>
<p> 
 </p>
<p> 
 </p>
<p> 
 </p>
<p><img src="../imgs/2018/05/capture-4-2.png" alt=""></p>
<ol>
<li>车三平五 将５平６</li>
<li>车五平四 将６平５</li>
<li>车四退一 车４平５</li>
<li>仕四退五 卒６平５</li>
<li>仕五退六 卒５平４</li>
<li>帅五退一 卒４平３</li>
<li>帅五退一 卒３平４</li>
<li>帅五平四 车５平６</li>
<li>车四进四 马５进７</li>
<li>相三退五</li>
</ol>
<p><img src="../imgs/2018/05/capture-5-1.png" alt=""></p>
<ol>
<li>车九平五 将５平６</li>
<li>车五平四 将６平５</li>
<li>车四退一 车４平５</li>
<li>仕四进五 象７进９</li>
<li>仕五退六 象９进７</li>
<li>仕四退五 象７退９</li>
<li>仕五进六 象９进７</li>
<li>帅五退一 象７退９</li>
<li>帅五退一 象９退７</li>
<li>帅五平四 车５平６</li>
<li>车四进二 车５平６</li>
<li>车四进二</li>
</ol>
<p><img src="../imgs/2018/05/capture-6-1.png" alt=""></p>
<ol>
<li>帅六平五 炮５退１</li>
<li>车二进一 炮５退１</li>
<li>车二进一 炮５退１</li>
<li>车二进一 炮５退１</li>
<li>车二进一 炮５退１</li>
<li>车二进一 炮５进１</li>
<li>车二平五 将５平６</li>
<li>车五平四 将６平５</li>
<li>帅五平四 士４退５</li>
<li>车四平五 将５平４</li>
<li>车五平六 将４平５</li>
<li>车六进二</li>
</ol>
<p><img src="../imgs/2018/05/capture-7-1.png" alt=""></p>
<ol>
<li>车九退一 将４进１</li>
<li>车九退四 卒４进１</li>
<li>帅六退一 卒４进１</li>
<li>帅六平五 将４退１</li>
<li>车九进四 将４进１</li>
<li>车九退六 卒４进１</li>
<li>帅五进一 将４退１</li>
<li>车九进六 将４进１</li>
<li>车九退五 将４退１</li>
<li>车九平六 将４平５</li>
<li>帅五平六 车６退１</li>
<li>车六进五 将５退１</li>
<li>车六进一 将５进１</li>
<li>车六平四</li>
</ol>
<p><img src="../imgs/2018/05/capture-9-1.png" alt=""></p>
<p><img src="../imgs/2018/05/capture-10-1.png" alt=""></p>
<ol>
<li>车九平六 将４平５</li>
<li>车六平五 将５平４</li>
<li>帅四平五 将４退１</li>
<li>车五平七 车９退１</li>
<li>车七进二 将４进１</li>
<li>车七退五 炮５退１</li>
<li>车七平六 将４平５</li>
<li>车六进一 炮５退１</li>
<li>车六进一 炮５退１</li>
<li>车六进一 炮５进４</li>
<li>车六平五 将５平４</li>
<li>帅五进一 车９平５</li>
<li>车五进三</li>
</ol>]]></content>
        </item>
        
        <item>
            <title>排局-09</title>
            <link>/posts/xiangqi/2018-05-06-endgame-09/</link>
            <pubDate>Sun, 06 May 2018 15:05:02 +0800</pubDate>
            
            <guid>/posts/xiangqi/2018-05-06-endgame-09/</guid>
            <description>车五退一 炮５进６ 兵五平四 卒９平８ 相三退一 象７退５ 后兵进一 炮５退４ 后兵进一 卒６平５ 帅五平四  第一步只有车五退一可以获胜</description>
            <content type="html"><![CDATA[<p><img src="../imgs/2018/05/capture-1-2.png" alt=""></p>
<p> 
 </p>
<p> 
 </p>
<p> 
 </p>
<p><img src="../imgs/2018/05/capture-2-2.png" alt=""></p>
<ol>
<li>车五退一 炮５进６</li>
<li>兵五平四 卒９平８</li>
<li>相三退一 象７退５</li>
<li>后兵进一 炮５退４</li>
<li>后兵进一 卒６平５</li>
<li>帅五平四</li>
</ol>
<p>第一步只有车五退一可以获胜</p>
]]></content>
        </item>
        
        <item>
            <title>排局-08</title>
            <link>/posts/xiangqi/2018-05-06-endgame-08/</link>
            <pubDate>Sun, 06 May 2018 15:01:11 +0800</pubDate>
            
            <guid>/posts/xiangqi/2018-05-06-endgame-08/</guid>
            <description>2b6/9/3k5/9/6b2/6B2/9/3A5/4AK3/p4CB1p w
如图形势，红方当然可以连续打掉两个黑卒。但这样黑方得以调整阵型，红方无法取胜。
   正确的走法是借叫杀之机，调整士相，将黑方双象赶到两边，进而获胜。
 炮四平六 将４平５ 炮六平五 将５平４ 仕五退四 将４平５  如改走将4退1，则帅四平五，红必得象，胜定。
相三退五 将５平４ 相五进七 将４平５ 仕四进五 将５平４ 炮五平七  驱黑象到边线。
&amp;hellip;&amp;hellip; 象３进１ 炮七平六 将４平５ 炮六平五 将５平４ 仕五进四 将４平５ 相七退五 将５平６ 帅四平五 将６平５ 帅五平六  红帅移行换位。
&amp;hellip;&amp;hellip; 将５平４ 相五进三 将４平５ 仕六退五 将５平６ 仕五退六 将６平５ 相三进五 将５平６ 相五进七 将６平５ 仕六进五 将５平６ 炮五平三 象７退９  再驱另一象到边线。
帅六进一 将６退１ 帅六平五 红胜。  </description>
            <content type="html"><![CDATA[<p><img src="../imgs/2018/05/capture-14.png" alt=""></p>
<p><a href="https://www.chessdb.cn/query/?2b6/9/3k5/9/6b2/6B2/9/3A5/4AK3/p4CB1p%20w">2b6/9/3k5/9/6b2/6B2/9/3A5/4AK3/p4CB1p w</a></p>
<p>如图形势，红方当然可以连续打掉两个黑卒。但这样黑方得以调整阵型，红方无法取胜。</p>
<p> 
 </p>
<p> 
 </p>
<p> 
 </p>
<p>正确的走法是借叫杀之机，调整士相，将黑方双象赶到两边，进而获胜。</p>
<ol>
<li>炮四平六 将４平５</li>
<li>炮六平五 将５平４</li>
<li>仕五退四 将４平５</li>
</ol>
<p>如改走将4退1，则帅四平五，红必得象，胜定。</p>
<ol start="4">
<li>相三退五 将５平４</li>
<li>相五进七 将４平５</li>
<li>仕四进五 将５平４</li>
<li>炮五平七</li>
</ol>
<p>驱黑象到边线。</p>
<ol start="7">
<li>&hellip;&hellip;        象３进１</li>
<li>炮七平六 将４平５</li>
<li>炮六平五 将５平４</li>
<li>仕五进四 将４平５</li>
<li>相七退五 将５平６</li>
<li>帅四平五 将６平５</li>
<li>帅五平六</li>
</ol>
<p>红帅移行换位。</p>
<ol start="13">
<li>&hellip;&hellip;        将５平４</li>
<li>相五进三 将４平５</li>
<li>仕六退五 将５平６</li>
<li>仕五退六 将６平５</li>
<li>相三进五 将５平６</li>
<li>相五进七 将６平５</li>
<li>仕六进五 将５平６</li>
<li>炮五平三 象７退９</li>
</ol>
<p>再驱另一象到边线。</p>
<ol start="21">
<li>帅六进一 将６退１</li>
<li>帅六平五 红胜。</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>排局-07</title>
            <link>/posts/xiangqi/2018-05-05-endgame-07/</link>
            <pubDate>Sat, 05 May 2018 23:18:22 +0800</pubDate>
            
            <guid>/posts/xiangqi/2018-05-05-endgame-07/</guid>
            <description>4ka3/9/5a3/6CC1/9/9/9/3K5/9/8c w
如图形势，红方仅有双炮做攻，似乎难以进取。
   第一步的进攻方向很是重要，如果沉底叫将，则与胜利失之交臂。</description>
            <content type="html"><![CDATA[<p><img src="../imgs/2018/05/capture-4-1.png" alt=""></p>
<p><a href="https://www.chessdb.cn/query/?4ka3/9/5a3/6CC1/9/9/9/3K5/9/8c%20w">4ka3/9/5a3/6CC1/9/9/9/3K5/9/8c w</a></p>
<p>如图形势，红方仅有双炮做攻，似乎难以进取。</p>
<p> 
 </p>
<p> 
 </p>
<p> 
 </p>
<p>第一步的进攻方向很是重要，如果沉底叫将，则与胜利失之交臂。</p>
]]></content>
        </item>
        
        <item>
            <title>排局-06</title>
            <link>/posts/xiangqi/2018-05-05-endgame-06/</link>
            <pubDate>Sat, 05 May 2018 22:21:07 +0800</pubDate>
            
            <guid>/posts/xiangqi/2018-05-05-endgame-06/</guid>
            <description>3r1r3/5k3/3a1a3/4C4/9/9/9/C8/5K3/3A5 w
如图形式，红方双炮巧妙腾挪，迫使黑方子力自相堵塞，最终一举获胜。
   此局的进攻思路比较直接，运炮叫将，利用黑士自相阻塞，重炮或者闷宫而胜。
 炮九平四 将６平５ 炮五退六！  红方退炮引而不发，伏有士六进五， 将5平4，炮四平六，士4退5，炮五平六重炮杀。黑方只有先将5平4才能解杀，红方则士六进五追杀：
&amp;hellip;&amp;hellip; 将５平４ 仕六进五 士４退５  黑方退士也是仅有的解着。如图形式，直观的攻法是架炮做杀，但均难以奏效。试演两变如下：
a.
炮四平六 将４进１ 帅四进一 车４平３ 帅四平五 车３进９  红方无杀，黑方胜势
b.
炮五平六 将４进１ 仕五进六 将４平５  红方无杀，黑方胜势
正确的走法是先士五进六做准备。细看之下，其实这是叫杀，演变如下：
仕五进六 车４平３？ 炮五平六 士５进４ 仕六退五 将４平５ 炮六平五 将５平４ 炮四平六 士４退５ 炮五平六 重炮胜  此路攻法虽是连杀，但需要来回运炮，粗看之下不易发现，可以算作此局的核心。
仕五进六扬士之后，黑方无暇挪车。最顽强的防守是先将4进1，当然红方辗转腾挪，攻势依然紧凑：
仕五进六 将４进１ 帅四平五！ 将４退１ 炮五平六 士５进４ 帅五平四！  以上着法，红方先进帅做杀，逼黑方下将，而后平炮打将，待黑方扬士时候再出帅，次序井然。注意此时红方仍然威胁士六退五然后连杀。
&amp;hellip;&amp;hellip; 将４平５ 仕六退五 将５退１  红方出帅，黑方顺势占中解杀。然而红方一手士六退五继续做杀，此时四六两路均已被控制，黑方只有坐将求生，但仍难免被重炮：
炮六平五 士６退５ 仕五退六 士５进６ 炮四平五  从开始的局面看，谁又能想到最后黑将会在原位被擒住呢？</description>
            <content type="html"><![CDATA[<p><img src="../imgs/2018/05/capture-13.png" alt=""></p>
<p><a href="https://www.chessdb.cn/query/?3r1r3/5k3/3a1a3/4C4/9/9/9/C8/5K3/3A5%20w%22">3r1r3/5k3/3a1a3/4C4/9/9/9/C8/5K3/3A5 w</a></p>
<p>如图形式，红方双炮巧妙腾挪，迫使黑方子力自相堵塞，最终一举获胜。</p>
<p> 
 </p>
<p> 
 </p>
<p> 
 </p>
<p>此局的进攻思路比较直接，运炮叫将，利用黑士自相阻塞，重炮或者闷宫而胜。</p>
<ol>
<li>炮九平四 将６平５</li>
<li>炮五退六！</li>
</ol>
<p>红方退炮引而不发，伏有士六进五， 将5平4，炮四平六，士4退5，炮五平六重炮杀。黑方只有先将5平4才能解杀，红方则士六进五追杀：</p>
<ol start="2">
<li>&hellip;&hellip;        将５平４</li>
<li>仕六进五 士４退５</li>
</ol>
<p>黑方退士也是仅有的解着。如图形式，直观的攻法是架炮做杀，但均难以奏效。试演两变如下：</p>
<p><img src="../imgs/2018/05/capture-1-1.png" alt=""></p>
<p>a.</p>
<ol start="4">
<li>炮四平六 将４进１</li>
<li>帅四进一 车４平３</li>
<li>帅四平五 车３进９</li>
</ol>
<p>红方无杀，黑方胜势</p>
<p>b.</p>
<ol start="4">
<li>炮五平六 将４进１</li>
<li>仕五进六 将４平５</li>
</ol>
<p>红方无杀，黑方胜势</p>
<p>正确的走法是先士五进六做准备。细看之下，其实这是叫杀，演变如下：</p>
<ol start="4">
<li>仕五进六 车４平３？</li>
<li>炮五平六 士５进４</li>
<li>仕六退五 将４平５</li>
<li>炮六平五 将５平４</li>
<li>炮四平六 士４退５</li>
<li>炮五平六 重炮胜</li>
</ol>
<p>此路攻法虽是连杀，但需要来回运炮，粗看之下不易发现，可以算作此局的核心。</p>
<p>仕五进六扬士之后，黑方无暇挪车。最顽强的防守是先将4进1，当然红方辗转腾挪，攻势依然紧凑：</p>
<ol start="4">
<li>仕五进六 将４进１</li>
<li>帅四平五！ 将４退１</li>
<li>炮五平六 士５进４</li>
<li>帅五平四！</li>
</ol>
<p><img src="../imgs/2018/05/capture-2-1.png" alt=""></p>
<p>以上着法，红方先进帅做杀，逼黑方下将，而后平炮打将，待黑方扬士时候再出帅，次序井然。注意此时红方仍然威胁士六退五然后连杀。</p>
<ol start="7">
<li>&hellip;&hellip;        将４平５</li>
<li>仕六退五 将５退１</li>
</ol>
<p><img src="../imgs/2018/05/capture-3-1.png" alt=""></p>
<p>红方出帅，黑方顺势占中解杀。然而红方一手士六退五继续做杀，此时四六两路均已被控制，黑方只有坐将求生，但仍难免被重炮：</p>
<ol start="9">
<li>炮六平五 士６退５</li>
<li>仕五退六 士５进６</li>
<li>炮四平五</li>
</ol>
<p>从开始的局面看，谁又能想到最后黑将会在原位被擒住呢？</p>
]]></content>
        </item>
        
        <item>
            <title>排局-05</title>
            <link>/posts/xiangqi/2018-05-04-endgame-05/</link>
            <pubDate>Fri, 04 May 2018 17:13:21 +0800</pubDate>
            
            <guid>/posts/xiangqi/2018-05-04-endgame-05/</guid>
            <description>6R2/3r5/3kr4/9/9/9/9/5C3/4A4/3A1K3 w
如图，红方似乎可以车三退三叫杀得车．可红方的取胜之路真的如此简单嘛？
   显然不是这样简单&amp;ndash;不过黑方的应对也可谓奇思妙想:
 车三退三 车５退１!  一着花心车龟缩防守，红方也暂时无计可施．此时平车打将会自找麻烦，因为黑方平将躲避后会形成兑车，红方反而不好处理．不过借打将之机调整炮位，进而扬士叫杀似乎是可行之策．
车三进一 车５进１ 炮四进五 车５退１ 炮四退六 车５进１ 车三退一 车５退１ 仕五进六  此时红方伏有炮四平六，将４平５，车三平五的杀着．黑方不能车５平６牵炮，因为红方车三进一绝杀．其他解杀手段均会丢４路车．看似红方已经取得了胜利，但这真的是黑方最顽强的抵抗嘛？非也！惯性思维导致黑方在第５回合还是退花心车，但此时红炮的位置已经挡住了自己的老帅，所以黑方可以车５平８反杀！
５．　车５平８！
此时红方无暇抽车，只有借打将之机先占中路，然后进帅做杀：
车三平六 将４平５ 车六平五 将５平４ 帅四平五  此时黑方有两种防守方法，均难逃一败：
a.
&amp;hellip;&amp;hellip; 车４平８ 仕五退四 前车进１ 车五进一 将４退１ 炮四平六 前车进５  此路变化黑方双车并线，与红方邀兑．无奈红方借先手打将，进而运炮卡位，胜势已成．前车进５是比较顽强的防守．如果后车进１？则车五进一！将４退１，车五退四，红胜定．注意这里车五进一的过们是必须的，如果直接车五退三，黑方有前车进２！红方车五平六，黑有后车平４，反而节外生枝．
仕六进五 后车进５ 车五退一 后车退４ 车五退三  以上几步红方顿挫井然，如下图形势，黑方如果动前车，则红方士五进六得车胜．黑方如果动将或者移动后车，如将４退１，红方仍有士五进六，弃炮绝杀！以下黑方前车平４，车五平六，车８平４，车六进四绝杀红胜．
此路变化，黑方竖向连车难以抵挡红方进攻，如果改为横向会怎样呢？
b.
&amp;hellip;&amp;hellip; 车４平７ 仕五退四 将４退１ 炮四平六 车７进１ 车五平六 车７平４  此路变化黑车会被红方栓住，但以炮换车红方只能得到和局，所以红方并不会轻易交换．
仕六进五 车８平５ 炮六退一　红胜定  红方士六进五，暗伏车六进一，将４进１，士五进六绝杀．黑方不能简单车８进１弃车解杀，否则仍是车六进一，将４进１，士五进六，红得车亦胜．
从最初的车三退三看似一步即胜，到后来的占中，架炮，红方的取胜之路可谓曲折．</description>
            <content type="html"><![CDATA[<p><img src="../imgs/2018/05/capture-4.png" alt=""></p>
<p><a href="https://www.chessdb.cn/query/?6R2/3r5/3kr4/9/9/9/9/5C3/4A4/3A1K3%20w">6R2/3r5/3kr4/9/9/9/9/5C3/4A4/3A1K3 w</a></p>
<p>如图，红方似乎可以车三退三叫杀得车．可红方的取胜之路真的如此简单嘛？</p>
<p> 
 </p>
<p> 
 </p>
<p> 
 </p>
<p>显然不是这样简单&ndash;不过黑方的应对也可谓奇思妙想:</p>
<ol>
<li>车三退三 车５退１!</li>
</ol>
<p>一着花心车龟缩防守，红方也暂时无计可施．此时平车打将会自找麻烦，因为黑方平将躲避后会形成兑车，红方反而不好处理．不过借打将之机调整炮位，进而扬士叫杀似乎是可行之策．</p>
<ol start="2">
<li>车三进一 车５进１</li>
<li>炮四进五 车５退１</li>
<li>炮四退六 车５进１</li>
<li>车三退一 车５退１</li>
<li>仕五进六</li>
</ol>
<p><img src="../imgs/2018/05/capture-5.png" alt=""></p>
<p>此时红方伏有炮四平六，将４平５，车三平五的杀着．黑方不能车５平６牵炮，因为红方车三进一绝杀．其他解杀手段均会丢４路车．看似红方已经取得了胜利，但这真的是黑方最顽强的抵抗嘛？非也！惯性思维导致黑方在第５回合还是退花心车，但此时红炮的位置已经挡住了自己的老帅，所以黑方可以车５平８反杀！</p>
<p>５．　　　　车５平８！</p>
<p><img src="../imgs/2018/05/capture-6.png" alt=""></p>
<p>此时红方无暇抽车，只有借打将之机先占中路，然后进帅做杀：</p>
<ol start="6">
<li>车三平六 将４平５</li>
<li>车六平五 将５平４</li>
<li>帅四平五</li>
</ol>
<p><img src="../imgs/2018/05/capture-8.png" alt=""></p>
<p>此时黑方有两种防守方法，均难逃一败：</p>
<p>a.</p>
<ol start="8">
<li>&hellip;&hellip;        车４平８</li>
<li>仕五退四 前车进１</li>
<li>车五进一 将４退１</li>
<li>炮四平六 前车进５</li>
</ol>
<p><img src="../imgs/2018/05/capture-9.png" alt=""></p>
<p>此路变化黑方双车并线，与红方邀兑．无奈红方借先手打将，进而运炮卡位，胜势已成．前车进５是比较顽强的防守．如果后车进１？则车五进一！将４退１，车五退四，红胜定．注意这里车五进一的过们是必须的，如果直接车五退三，黑方有前车进２！红方车五平六，黑有后车平４，反而节外生枝．</p>
<ol start="12">
<li>仕六进五 后车进５</li>
<li>车五退一 后车退４</li>
<li>车五退三</li>
</ol>
<p>以上几步红方顿挫井然，如下图形势，黑方如果动前车，则红方士五进六得车胜．黑方如果动将或者移动后车，如将４退１，红方仍有士五进六，弃炮绝杀！以下黑方前车平４，车五平六，车８平４，车六进四绝杀红胜．</p>
<p><img src="../imgs/2018/05/capture-10.png" alt=""></p>
<p>此路变化，黑方竖向连车难以抵挡红方进攻，如果改为横向会怎样呢？</p>
<p>b.</p>
<ol start="8">
<li>&hellip;&hellip;        车４平７</li>
<li>仕五退四 将４退１</li>
<li>炮四平六 车７进１</li>
<li>车五平六 车７平４</li>
</ol>
<p><img src="../imgs/2018/05/capture-12.png" alt=""></p>
<p>此路变化黑车会被红方栓住，但以炮换车红方只能得到和局，所以红方并不会轻易交换．</p>
<ol start="12">
<li>仕六进五 车８平５</li>
<li>炮六退一　红胜定</li>
</ol>
<p>红方士六进五，暗伏车六进一，将４进１，士五进六绝杀．黑方不能简单车８进１弃车解杀，否则仍是车六进一，将４进１，士五进六，红得车亦胜．</p>
<p>从最初的车三退三看似一步即胜，到后来的占中，架炮，红方的取胜之路可谓曲折．</p>
]]></content>
        </item>
        
        <item>
            <title>排局-04</title>
            <link>/posts/xiangqi/2018-05-04-endgame-04/</link>
            <pubDate>Fri, 04 May 2018 16:00:41 +0800</pubDate>
            
            <guid>/posts/xiangqi/2018-05-04-endgame-04/</guid>
            <description>1R1ara3/9/4k4/9/2b6/6B2/9/5K3/7p1/9 w
如图形势，红方进攻子力仅有一车，如何才能利用黑车的位置取得胜利？
   最直观的思路并不能奏效：
 车八退三 士６进５ 车八平五 将５平４ 帅四平五 将４退１ 车五平六 士５进４  虽然黑方篡位车位置尴尬，但这样直接叫吃还是太过急躁．同样，如果直接车八退八，确实可以吃掉黑卒，但红方并不能取得胜利．
正确的走法是先将黑将打到二楼，然后退车捉卒：
 车八退二 将５退１ 车八退六  此时黑方虽然没有丢车之虞，但也无法疏通子力．当然不能回中象，否则红方车八进七绝杀．将５平４躲避会被红方车八平六先手带将吃掉卒，上将则会送车．所以黑方只有躲卒．这里有一个小陷阱，就是黑方卒８平７送吃：
&amp;hellip;&amp;hellip; 卒８平７ 车八平三 象３退５ 车三平八 将５平４  红方无法取胜，和棋
红方急于吃卒，但车被自己的高相挡住，黑方侥幸某得和局．细看之下，死卒不急吃，红方没有必要立刻杀卒，可以先落边相给车通头．
相三退一  接下来，黑卒走投无路，红方可以将其吃掉并且保持车通头，已成胜势．具体的胜方可以参考后文着法．
黑方较为顽强的抵抗是卒８进１沉底：
 车八退二 将５退１ 车八退六 卒８进１ 车八退一 卒８平７！ 相三退一 卒７平６！  黑方先将卒沉底，然后平移进入红方九宫，如入无人之境．红方为了保持车通头，竟然不能简单将其杀掉．如下图形势，红方如帅四退一捉卒，黑方可以卒６平５占中！红方车八平五杀卒叫将则象３退５，进而某得和局．
那红方怎样才能取得胜利呢？这里红方需要切换一下进攻思路，不再用车捉卒，而是采用排局中常见的捉弄底卒的方式来将其擒获．正着初看之下有点不可思议，红方不仅不吃卒，还主动抬车；并且抬车的方式必须是车八进三或进四，连看起来更有威胁的车八进六都不行：
车八进三 卒６平５ 相一进三 卒５平４ 相三退五 卒４平５ 帅四退一 卒５平４ 帅四退一  以上着法对于排局爱好者并不陌生，首先运相回中路让黑卒无法离开九宫，然后下帅挤掉其仅有的活动空间．此时黑方只有动将，而对红方来说，取得胜利已经不再困难：
&amp;hellip;&amp;hellip; 将５平４ 车八平六 将４平５ 车六进三 卒４平５  红方叫将后进车点穴，黑方无子可动．其实黑方的高象也是有意为之，如果黑方是底象，没有这一手塞象眼，红方还是无法取得胜利．此时只有方弃卒一搏，不过仍难免一败：
帅四平五 将５平６ 车六平四 将６平５ 帅五平四 将５平４ 车四平六 将４平５ 相五进七　红胜定  如果黑方先出将，则红方先车八平六叫将然后车六进三点穴．黑卒还是会被困死．细心的读者可能已经发现前面为什么只能车八进三或进四，不能直接进六．否则，由于不需要进车点穴，差了一步棋．换句话说，最后单双步不对，并不能困死黑卒．</description>
            <content type="html"><![CDATA[<p><img src="../imgs/2018/05/capture-04252018.png" alt=""></p>
<p><a href="https://www.chessdb.cn/query/?1R1ara3/9/4k4/9/2b6/6B2/9/5K3/7p1/9%20w">1R1ara3/9/4k4/9/2b6/6B2/9/5K3/7p1/9 w</a></p>
<p>如图形势，红方进攻子力仅有一车，如何才能利用黑车的位置取得胜利？</p>
<p> 
 </p>
<p> 
 </p>
<p> 
 </p>
<p>最直观的思路并不能奏效：</p>
<ol>
<li>车八退三 士６进５</li>
<li>车八平五 将５平４</li>
<li>帅四平五 将４退１</li>
<li>车五平六 士５进４</li>
</ol>
<p>虽然黑方篡位车位置尴尬，但这样直接叫吃还是太过急躁．同样，如果直接车八退八，确实可以吃掉黑卒，但红方并不能取得胜利．</p>
<p>正确的走法是先将黑将打到二楼，然后退车捉卒：</p>
<ol>
<li>车八退二 将５退１</li>
<li>车八退六</li>
</ol>
<p>此时黑方虽然没有丢车之虞，但也无法疏通子力．当然不能回中象，否则红方车八进七绝杀．将５平４躲避会被红方车八平六先手带将吃掉卒，上将则会送车．所以黑方只有躲卒．这里有一个小陷阱，就是黑方卒８平７送吃：</p>
<ol start="2">
<li>&hellip;&hellip;        卒８平７</li>
<li>车八平三 象３退５</li>
<li>车三平八 将５平４</li>
</ol>
<p>红方无法取胜，和棋</p>
<p>红方急于吃卒，但车被自己的高相挡住，黑方侥幸某得和局．细看之下，死卒不急吃，红方没有必要立刻杀卒，可以先落边相给车通头．</p>
<ol start="3">
<li>相三退一</li>
</ol>
<p><img src="../imgs/2018/05/capture.png" alt=""></p>
<p>接下来，黑卒走投无路，红方可以将其吃掉并且保持车通头，已成胜势．具体的胜方可以参考后文着法．</p>
<p>黑方较为顽强的抵抗是卒８进１沉底：</p>
<ol>
<li>车八退二 将５退１</li>
<li>车八退六 卒８进１</li>
<li>车八退一 卒８平７！</li>
<li>相三退一 卒７平６！</li>
</ol>
<p>黑方先将卒沉底，然后平移进入红方九宫，如入无人之境．红方为了保持车通头，竟然不能简单将其杀掉．如下图形势，红方如帅四退一捉卒，黑方可以卒６平５占中！红方车八平五杀卒叫将则象３退５，进而某得和局．</p>
<p><img src="../imgs/2018/05/capture-2.png" alt=""></p>
<p>那红方怎样才能取得胜利呢？这里红方需要切换一下进攻思路，不再用车捉卒，而是采用排局中常见的捉弄底卒的方式来将其擒获．正着初看之下有点不可思议，红方不仅不吃卒，还主动抬车；并且抬车的方式必须是车八进三或进四，连看起来更有威胁的车八进六都不行：</p>
<ol start="5">
<li>车八进三 卒６平５</li>
<li>相一进三 卒５平４</li>
<li>相三退五 卒４平５</li>
<li>帅四退一 卒５平４</li>
<li>帅四退一</li>
</ol>
<p><img src="../imgs/2018/05/capture-3.png" alt=""></p>
<p>以上着法对于排局爱好者并不陌生，首先运相回中路让黑卒无法离开九宫，然后下帅挤掉其仅有的活动空间．此时黑方只有动将，而对红方来说，取得胜利已经不再困难：</p>
<ol start="9">
<li>&hellip;&hellip;        将５平４</li>
<li>车八平六 将４平５</li>
<li>车六进三 卒４平５</li>
</ol>
<p>红方叫将后进车点穴，黑方无子可动．其实黑方的高象也是有意为之，如果黑方是底象，没有这一手塞象眼，红方还是无法取得胜利．此时只有方弃卒一搏，不过仍难免一败：</p>
<ol start="12">
<li>帅四平五 将５平６</li>
<li>车六平四 将６平５</li>
<li>帅五平四 将５平４</li>
<li>车四平六 将４平５</li>
<li>相五进七　红胜定</li>
</ol>
<p>如果黑方先出将，则红方先车八平六叫将然后车六进三点穴．黑卒还是会被困死．细心的读者可能已经发现前面为什么只能车八进三或进四，不能直接进六．否则，由于不需要进车点穴，差了一步棋．换句话说，最后单双步不对，并不能困死黑卒．</p>
<p>本局的精妙之处在于借捉卒之机另其自陷虎口，转而运相退帅将其困毙，颇有声动击西之妙．现在看来，最开始的那句＂红方进攻子力仅有一车＂也需商榷，因为在排局中，士相甚至老帅都可以用来进攻．</p>
]]></content>
        </item>
        
        <item>
            <title>排局-03</title>
            <link>/posts/xiangqi/2018-01-18-endgame-03/</link>
            <pubDate>Thu, 18 Jan 2018 20:47:50 +0800</pubDate>
            
            <guid>/posts/xiangqi/2018-01-18-endgame-03/</guid>
            <description>2rr5/9/3a1k3/3P5/2R6/2B6/9/9/3K5/9 w
如图，黑方将位不安，且双车略背，红方如何凭借先行之利取胜？
   按照惯例，首先分析一路不成熟的攻势，打将之后占中做杀：
 车七平四 将６平５ 车四平五 将５平６ 帅六平五 车４平５ 兵六平五 将６退１  红方平兵继续叫杀，黑方当然不能直接车5进3砍兵，否则红方顺势车五进一吃掉之后即是绝杀。黑如车3进4弃车解杀，则红方兵五平四之后吃掉底车，仍是胜势。黑方下将正着，红如兵五进一，黑方便可以车5进2某得和局。
车五平四 将６平５ 兵五进一 将５平４ 车四进三 将４退１  红劣黑胜
黑方下将是一步容易被忽略的着法。最初算到这里的时候我以为黑方只能落士，红兵五进一之后由于黑车低头，形成巧胜。不料黑方有此着躲避，从而反败为胜。 所以红方正确的攻法是打两将之后平兵叫杀：
 车七平四 将６平５ 车四平五 将５平６ 兵六平五 将６退１  黑方当然不能士4退5打将，否则红方帅六平五占中之后，黑方速败。
兵五进一 将６退１ 车五平四 将６平５ 车四平二 将５平６  此时红方走不到兵五平四做杀，因为黑方可以士4退5带将抽掉。又不能帅六平五，否则黑方车3进5弃车杀相可以谋和。红方攻势暂时受阻，怎样才能打开局面呢？
车二进四 将６进１ 车二退五 将６退１  红方借叫杀之机保住自己的高相，使得黑方杀相谋和的计划落空。但此时平帅黑方还是可以车3进4通头，下步即可以抢占中路，红方似乎还是难有进取。
帅六平五 车３进４  如图形势，红方有两路较为直观的攻法，但都难以奏效：
a.
兵五平四 车４平５！ 相七退五 车３进４ 帅五退一 车５进７ 黑胜  黑方车4平5妙手，粉碎了红方的攻势，一举反败为胜
b.
车二平四 将６平５ 帅五平四 士４退５ 车四进四 车３平６!</description>
            <content type="html"><![CDATA[<p><img src="../imgs/2018/01/5.png" alt=""></p>
<p><a href="https://www.chessdb.cn/query/?2rr5/9/3a1k3/3P5/2R6/2B6/9/9/3K5/9%20w">2rr5/9/3a1k3/3P5/2R6/2B6/9/9/3K5/9 w</a></p>
<p>如图，黑方将位不安，且双车略背，红方如何凭借先行之利取胜？</p>
<p> 
 </p>
<p> 
 </p>
<p> 
 </p>
<p>按照惯例，首先分析一路不成熟的攻势，打将之后占中做杀：</p>
<ol>
<li>车七平四 将６平５</li>
<li>车四平五 将５平６</li>
<li>帅六平五 车４平５</li>
<li>兵六平五 将６退１</li>
</ol>
<p>红方平兵继续叫杀，黑方当然不能直接车5进3砍兵，否则红方顺势车五进一吃掉之后即是绝杀。黑如车3进4弃车解杀，则红方兵五平四之后吃掉底车，仍是胜势。黑方下将正着，红如兵五进一，黑方便可以车5进2某得和局。</p>
<ol start="5">
<li>车五平四 将６平５</li>
<li>兵五进一 将５平４</li>
<li>车四进三 将４退１</li>
</ol>
<p>红劣黑胜</p>
<p><img src="../imgs/2018/01/6.png" alt=""></p>
<p>黑方下将是一步容易被忽略的着法。最初算到这里的时候我以为黑方只能落士，红兵五进一之后由于黑车低头，形成巧胜。不料黑方有此着躲避，从而反败为胜。
所以红方正确的攻法是打两将之后平兵叫杀：</p>
<ol>
<li>车七平四 将６平５</li>
<li>车四平五 将５平６</li>
<li>兵六平五 将６退１</li>
</ol>
<p>黑方当然不能士4退5打将，否则红方帅六平五占中之后，黑方速败。</p>
<ol start="4">
<li>兵五进一 将６退１</li>
<li>车五平四 将６平５</li>
<li>车四平二 将５平６</li>
</ol>
<p>此时红方走不到兵五平四做杀，因为黑方可以士4退5带将抽掉。又不能帅六平五，否则黑方车3进5弃车杀相可以谋和。红方攻势暂时受阻，怎样才能打开局面呢？</p>
<ol start="7">
<li>车二进四 将６进１</li>
<li>车二退五 将６退１</li>
</ol>
<p>红方借叫杀之机保住自己的高相，使得黑方杀相谋和的计划落空。但此时平帅黑方还是可以车3进4通头，下步即可以抢占中路，红方似乎还是难有进取。</p>
<ol start="9">
<li>帅六平五 车３进４</li>
</ol>
<p>如图形势，红方有两路较为直观的攻法，但都难以奏效：</p>
<p><img src="../imgs/2018/01/9.png" alt=""></p>
<p>a.</p>
<ol start="10">
<li>兵五平四 车４平５！</li>
<li>相七退五 车３进４</li>
<li>帅五退一 车５进７ 黑胜</li>
</ol>
<p>黑方车4平5妙手，粉碎了红方的攻势，一举反败为胜</p>
<p>b.</p>
<ol start="10">
<li>车二平四 将６平５</li>
<li>帅五平四 士４退５</li>
<li>车四进四 车３平６!</li>
<li>车四退三 车４进８</li>
<li>帅四进一 车４平５</li>
<li>相七退五 车５进１!</li>
<li>帅四退一 车５退２</li>
</ol>
<p>黑方弃车照将的手法颇有排局味道，且即使红方落相盖车，黑方还是有沉底车的冷手，最终谋得和局。</p>
<p>红方的正确走法并不起眼：</p>
<ol start="10">
<li>相七退五</li>
</ol>
<p><img src="../imgs/2018/01/7.png" alt=""></p>
<p>红方一手轻巧的落相，同时威胁兵五平四绝杀和车二进五抽车，黑方立感不妙。第一感是车4平3，似乎既能解杀，又给车生根。其实不然，红用传统攻法获胜：</p>
<ol start="10">
<li>&hellip;&hellip;        车４平３</li>
<li>车二平四 将６平５</li>
<li>帅五平四 士４退５</li>
<li>车四进四 红胜定</li>
</ol>
<p>与前面弃车解杀的b变相比，此时红相已在中路，黑方抢不到中路，必败无疑。</p>
<p>于是黑方只有丢车保帅，车3平6弃车，而后负隅顽抗：</p>
<ol start="10">
<li>&hellip;&hellip;        车３平６</li>
<li>车二进五 将６进１</li>
<li>车二平六 士４退５</li>
</ol>
<p>黑落士后，红如心急误走车六退一，则黑方车6平5巧和！</p>
<ol start="13">
<li>车六平二 车６进４</li>
<li>帅五退一 士５进６</li>
</ol>
<p><img src="../imgs/2018/01/8.png" alt=""></p>
<p>困兽犹斗，此时红方已是必胜局面，但若是不得门道，恐怕难有突破。</p>
<ol start="15">
<li>车二退九 车６退１</li>
<li>帅五进一 车６退４</li>
<li>车二进一 将６退１</li>
<li>车二平四 车６进５</li>
<li>帅五平四 红胜定</li>
</ol>
<p>回看全局，红方打将顿挫保相而后进帅落相，可谓手筋，值得玩味。</p>
]]></content>
        </item>
        
        <item>
            <title>排局-02</title>
            <link>/posts/xiangqi/2018-01-11-endgame-02/</link>
            <pubDate>Thu, 11 Jan 2018 23:08:29 +0800</pubDate>
            
            <guid>/posts/xiangqi/2018-01-11-endgame-02/</guid>
            <description>rr1ak4/9/9/9/9/9/9/5K3/R8/3AC4 w
如图，双方子力不多，且黑方双车通头，红方怎样才能借先行之利取胜？
   初看之下，红方虽有空头炮，但黑方双车相连，抽将也得不到便宜。且边线双车对头，所以红方第一步究竟要不要打将就是值得思索的问题。如果打将，黑方必定士4进5，等红车再次打将离开中路，黑方可以有针对性的支士落士，红方难以进取。但若是不打将，则只有平车躲避，此时黑方可以进车打将，似乎很快可以化解红方尚不成熟的攻势。
当然，红方还是可以先车九平三叫杀（伏士六进五，士4进5，车三进八杀）。此时黑方并不能打将抽车，因为车2进7，帅四退一，车2进1? 士六进五，反将红胜。简单上将并不能解杀：
 车九平三 将５进１ 车三平五 将５平４ 车五平六 将４平５ 仕六进五 红胜  所以将5进1的走法是错误的。那黑方怎样才能化解红方攻势呢？看来只有先车2进7打将，红方必定帅四退一躲避。此时再将5进1，红方没法平车打将，是不是可以守住呢？非也，此时红方可以从竖线进攻：
 车九平三 车２进７ 帅四退一 将５进１ 车三进七 将５进１ 仕六进五 将５平４ 车三退二 红胜定  可惜，红方的胜利是建立在黑方的失误之上，当然正解也绝非寻常着法：
 车九平三 车２进７ 帅四退一 车１进９  黑方一手车1进9（亦可车2进2），明为送，实为捉，红方不能炮五平九，否则车2进1抽车黑速胜。因炮被牵制，士六进五也不成，所以红方只能车三进八借打将之机先吃一车。
车三进八 将５进１ 炮五平九  此时红方不仅净多一炮，且底车先捉黑士，怎么看黑方也是败势难逃。但黑方自有妙计：
&amp;hellip;&amp;hellip; 车２进１ 帅四进一 车２进１  黑方车2进1打将，迫使红帅定位。红方如果帅四退一下帅，黑方则车2进1捉双，随后车2平4吃士，然后车4平5占中成单车守和车炮之势。红方不肯，只好帅上三楼。黑方随即再度进车捉双。为什么黑方不直接车2进2捉双呢？这里按下不表，稍后揭晓。
炮九进九 车２平４ 车三平五 将５平４  </description>
            <content type="html"><![CDATA[<p><img src="../imgs/2018/01/3.png" alt="rr1ak4/9/9/9/9/9/9/5K3/R8/3AC4 w"></p>
<p><a href="https://www.chessdb.cn/query/?rr1ak4/9/9/9/9/9/9/5K3/R8/3AC4%20w">rr1ak4/9/9/9/9/9/9/5K3/R8/3AC4 w</a></p>
<p>如图，双方子力不多，且黑方双车通头，红方怎样才能借先行之利取胜？</p>
<p> 
 </p>
<p> 
 </p>
<p> 
 </p>
<p>初看之下，红方虽有空头炮，但黑方双车相连，抽将也得不到便宜。且边线双车对头，所以红方第一步究竟要不要打将就是值得思索的问题。如果打将，黑方必定士4进5，等红车再次打将离开中路，黑方可以有针对性的支士落士，红方难以进取。但若是不打将，则只有平车躲避，此时黑方可以进车打将，似乎很快可以化解红方尚不成熟的攻势。</p>
<p>当然，红方还是可以先车九平三叫杀（伏士六进五，士4进5，车三进八杀）。此时黑方并不能打将抽车，因为车2进7，帅四退一，车2进1? 士六进五，反将红胜。简单上将并不能解杀：</p>
<ol>
<li>车九平三 将５进１</li>
<li>车三平五 将５平４</li>
<li>车五平六 将４平５</li>
<li>仕六进五 红胜</li>
</ol>
<p>所以将5进1的走法是错误的。那黑方怎样才能化解红方攻势呢？看来只有先车2进7打将，红方必定帅四退一躲避。此时再将5进1，红方没法平车打将，是不是可以守住呢？非也，此时红方可以从竖线进攻：</p>
<ol>
<li>车九平三 车２进７</li>
<li>帅四退一 将５进１</li>
<li>车三进七 将５进１</li>
<li>仕六进五 将５平４</li>
<li>车三退二 红胜定</li>
</ol>
<p>可惜，红方的胜利是建立在黑方的失误之上，当然正解也绝非寻常着法：</p>
<ol>
<li>车九平三 车２进７</li>
<li>帅四退一 车１进９</li>
</ol>
<p><img src="../imgs/2018/01/3.png" alt=""></p>
<p>黑方一手车1进9（亦可车2进2），明为送，实为捉，红方不能炮五平九，否则车2进1抽车黑速胜。因炮被牵制，士六进五也不成，所以红方只能车三进八借打将之机先吃一车。</p>
<ol start="3">
<li>车三进八 将５进１</li>
<li>炮五平九</li>
</ol>
<p>此时红方不仅净多一炮，且底车先捉黑士，怎么看黑方也是败势难逃。但黑方自有妙计：</p>
<ol start="4">
<li>&hellip;&hellip;        车２进１</li>
<li>帅四进一 车２进１</li>
</ol>
<p>黑方车2进1打将，迫使红帅定位。红方如果帅四退一下帅，黑方则车2进1捉双，随后车2平4吃士，然后车4平5占中成单车守和车炮之势。红方不肯，只好帅上三楼。黑方随即再度进车捉双。为什么黑方不直接车2进2捉双呢？这里按下不表，稍后揭晓。</p>
<ol start="6">
<li>炮九进九 车２平４</li>
<li>车三平五 将５平４</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>排局-01</title>
            <link>/posts/xiangqi/2018-01-11-endgame-01/</link>
            <pubDate>Thu, 11 Jan 2018 23:04:07 +0800</pubDate>
            
            <guid>/posts/xiangqi/2018-01-11-endgame-01/</guid>
            <description>9/9/5k3/9/9/9/9/4BA2B/3K5/3A3Cc w
如图局面，是我不久前从残局库中发现的一个挺有意思的局面，红先胜。
   分析：
从初始盘面来看，双方各有一炮，红方有士相，黑方仅光将且在三楼，估计是要在困炮的同时调整阵型，最后白脸将杀。
最直接的思路是打两将之后扬相，然后帅占中路做杀。但黑方有一手叫闷可解：
 炮二平四 将６平５ 炮四平五 将５平６ 相五进三 将６平５ 仕六进五 将５平６ 帅六进一 炮９平８  此路虽不通，但红方另有一路攻法，就是先上帅，然后再运炮做攻。由于红炮占位，黑方走不到炮9平8，形势十分不妙。将如6平5红方则顺势炮二平五打将。炮9退1也难挽颓势：
 帅六进一 炮９退１ 炮二平四 炮９平６ 帅六退一 将６平５ 炮四平五 将５平６ 帅六平五 炮６进１ 相五进七 将６退１ 帅五进一 将６退１ 仕六进五 炮６退１ 炮五平四 将６进１ 仕五进六 将６进１ 帅五退一 捉死炮胜  当然，这则排局并非如此简单。黑方炮9退1不是应对帅六进一的最顽强走法。黑方有一手将6退1可以某得和局。下将后，红方当然不能急于炮二平四打将，否则黑方可以从容炮9平8再炮8退7防守。于是红方只有先飞相，但无论红相往哪边去，黑方都有妙手化解。
如图形势，如红飞三七高相，则黑方炮击底士，而后绕回防守，红方无计可施：
相五进七 炮９平４ 炮二平四 将６平５ 炮四平五 炮４平２  如红落相，黑方当然不能打士（否则炮被困死）。正确走法是将6平5占中：
相五退七 将６平５ 仕六进五 炮９平３ 炮二平五 将５平６ 帅六平五 炮３退７  红方自己落下来的底相被黑方打掉然后借机回防，也是十分有趣。
那正确的攻法是什么呢？还是先从运炮入手：
 炮二平四 将６平５ 炮四平五 将５平６ 相五进三 将６平５ 仕六进五 将５平６  红方直接上帅并不能奏效，但这里如果46路的子力调换一下，红帅在4路，士和黑将在6路，则黑方无法借助炮9平8防守。但红方怎样才能调整阵型，达到上述目标呢？且看后续着法：</description>
            <content type="html"><![CDATA[<p><img src="../imgs/2018/01/1.png" alt="9/9/5k3/9/9/9/9/4BA2B/3K5/3A3Cc w"></p>
<p><a href="https://www.chessdb.cn/query/?9/9/5k3/9/9/9/9/4BA2B/3K5/3A3Cc%20w">9/9/5k3/9/9/9/9/4BA2B/3K5/3A3Cc w</a></p>
<p>如图局面，是我不久前从残局库中发现的一个挺有意思的局面，红先胜。</p>
<p> 
 </p>
<p> 
 </p>
<p> 
 </p>
<p>分析：</p>
<p>从初始盘面来看，双方各有一炮，红方有士相，黑方仅光将且在三楼，估计是要在困炮的同时调整阵型，最后白脸将杀。</p>
<p>最直接的思路是打两将之后扬相，然后帅占中路做杀。但黑方有一手叫闷可解：</p>
<ol>
<li>炮二平四 将６平５</li>
<li>炮四平五 将５平６</li>
<li>相五进三 将６平５</li>
<li>仕六进五 将５平６</li>
<li>帅六进一 炮９平８</li>
</ol>
<p>此路虽不通，但红方另有一路攻法，就是先上帅，然后再运炮做攻。由于红炮占位，黑方走不到炮9平8，形势十分不妙。将如6平5红方则顺势炮二平五打将。炮9退1也难挽颓势：</p>
<ol>
<li>帅六进一 炮９退１</li>
<li>炮二平四 炮９平６</li>
<li>帅六退一 将６平５</li>
<li>炮四平五 将５平６</li>
<li>帅六平五 炮６进１</li>
<li>相五进七 将６退１</li>
<li>帅五进一 将６退１</li>
<li>仕六进五 炮６退１</li>
<li>炮五平四 将６进１</li>
<li>仕五进六 将６进１</li>
<li>帅五退一 捉死炮胜</li>
</ol>
<p>当然，这则排局并非如此简单。黑方炮9退1不是应对帅六进一的最顽强走法。黑方有一手将6退1可以某得和局。下将后，红方当然不能急于炮二平四打将，否则黑方可以从容炮9平8再炮8退7防守。于是红方只有先飞相，但无论红相往哪边去，黑方都有妙手化解。</p>
<p><img src="../imgs/2018/01/2.png" alt=""></p>
<p>如图形势，如红飞三七高相，则黑方炮击底士，而后绕回防守，红方无计可施：</p>
<ol start="2">
<li>相五进七 炮９平４</li>
<li>炮二平四 将６平５</li>
<li>炮四平五 炮４平２</li>
</ol>
<p>如红落相，黑方当然不能打士（否则炮被困死）。正确走法是将6平5占中：</p>
<ol start="2">
<li>相五退七 将６平５</li>
<li>仕六进五 炮９平３</li>
<li>炮二平五 将５平６</li>
<li>帅六平五 炮３退７</li>
</ol>
<p>红方自己落下来的底相被黑方打掉然后借机回防，也是十分有趣。</p>
<p>那正确的攻法是什么呢？还是先从运炮入手：</p>
<ol>
<li>炮二平四 将６平５</li>
<li>炮四平五 将５平６</li>
<li>相五进三 将６平５</li>
<li>仕六进五 将５平６</li>
</ol>
<p>红方直接上帅并不能奏效，但这里如果46路的子力调换一下，红帅在4路，士和黑将在6路，则黑方无法借助炮9平8防守。但红方怎样才能调整阵型，达到上述目标呢？且看后续着法：</p>
<ol start="5">
<li>仕五进六 将６平５</li>
<li>相三退五 将５平６</li>
<li>帅六平五 将６平５</li>
<li>帅五平四 将５平６</li>
<li>相五进三 将６平５</li>
</ol>
<p>红方借连续做杀之机，将底士高扬，并将中相落回，后将帅运至4路。黑方将6平5，是因红威胁进帅绝杀，所以只得放弃4路。红方继续贯彻思路：</p>
<ol start="10">
<li>仕四退五 将５平４</li>
<li>帅四进一 炮９平８</li>
<li>帅四平五 红胜定</li>
</ol>
<p>本局独特之处在于，红方的攻法不仅是隔步杀，而且心中需要有一个明确的目标。离开这个目标，红方的着法都没有意义。一位好友指出，这局有些像数学题。我觉得在这局棋里，更多的是推理和排除，而不是传统意义上的计算。说来也巧，我们都是数学专业出身，所以对这类题目情有独钟。后续我还会发布几则类似味道的局面，欢迎大家批评指正。</p>
]]></content>
        </item>
        
    </channel>
</rss>
